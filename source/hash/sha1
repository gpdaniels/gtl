/*
Copyright (C) 2018-2024 Geoffrey Daniels. https://gpdaniels.com/

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, version 3 of the License only.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

#pragma once
#ifndef GTL_HASH_SHA1_HPP
#define GTL_HASH_SHA1_HPP

// Summary: An implementation of the sha1 hashing function.

#ifndef NDEBUG
#if defined(_MSC_VER)
#define __builtin_trap() __debugbreak()
#endif
/// @brief A simple assert macro to break the program if the sha1 is misused.
#define GTL_SHA1_ASSERT(ASSERTION, MESSAGE) static_cast<void>((ASSERTION) || (__builtin_trap(), 0))
#else
/// @brief At release time the assert macro is implemented as a nop.
#define GTL_SHA1_ASSERT(ASSERTION, MESSAGE) static_cast<void>(0)
#endif

namespace gtl {
    /// @brief  The sha1 class computes and SHA0 hash of a sequence of data.
    class sha1 final {
    public:
        /// @brief  Handy variable for accessing the size in bits.
        constexpr static const unsigned long long int size = 160;

        /// @brief  Size of the hash in bytes.
        constexpr static const unsigned long long int hash_size = sha1::size / 8;

        /// @brief  Internal size of each processed block of data in bytes.
        constexpr static const unsigned long long int block_size = 64;

        /// @brief  Number of rounds used to process each block of data.
        constexpr static const unsigned long long int processing_rounds = 80;

    public:
        /// @brief  Simple type to hold the hash data.
        struct hash_type final {
            unsigned char data[sha1::hash_size] = {
                0x67,
                0x45,
                0x23,
                0x01,
                0xEF,
                0xCD,
                0xAB,
                0x89,
                0x98,
                0xBA,
                0xDC,
                0xFE,
                0x10,
                0x32,
                0x54,
                0x76,
                0xC3,
                0xD2,
                0xE1,
                0xF0
            };
        };

    private:
        /// @brief  Internal type used to construct blocks of data for processing.
        struct block_type final {
            unsigned long long int length_bytes = 0;
            unsigned char data[sha1::block_size] = {};
        };

    private:
        /// @brief  The number of bytes of data that have been hashed.
        unsigned long long int hashed_length = 0;

        /// @brief  The current block of data being filled.
        block_type current_block = {};

        /// @brief  The current hash.
        hash_type current_hash = {};

        /// @brief  Flag showing whether the hash has been finalised.
        bool finalised = false;

    private:
        /// @brief  Packs four bytes into an unsigned int.
        /// @param  bytes The bytes to convert.
        /// @return The bytes packed into an unsigned int.
        constexpr static unsigned int pack_big_endian(const unsigned char bytes[4]) {
            return (static_cast<unsigned int>(bytes[0]) << 24) | (static_cast<unsigned int>(bytes[1]) << 16) | (static_cast<unsigned int>(bytes[2]) << 8) | (static_cast<unsigned int>(bytes[3]) << 0);
        }

        /// @brief  Unpacks four bytes from an unsigned int.
        /// @param  value The value to unpack.
        /// @param  bytes The bytes to receive the unpacked data.
        constexpr static void unpack_big_endian(unsigned int value, unsigned char bytes[4]) {
            bytes[0] = static_cast<unsigned char>((value >> 24) & 0xFF);
            bytes[1] = static_cast<unsigned char>((value >> 16) & 0xFF);
            bytes[2] = static_cast<unsigned char>((value >> 8) & 0xFF);
            bytes[3] = static_cast<unsigned char>((value >> 0) & 0xFF);
        }

        /// @brief  Rotate a 32 bit value left by a shift amount.
        /// @param  value The value to rotate.
        /// @param  shift The number of bits to rotate by.
        /// @return The value after it has been rotated left by shift bits.
        constexpr static unsigned int rotate_left(unsigned int value, unsigned int shift) {
            constexpr const unsigned int mask = (8 * sizeof(unsigned int) - 1);
            shift &= mask;
            return (value << shift) | (value >> ((static_cast<unsigned int>(-static_cast<signed int>(shift))) & mask));
        }

    private:
        /// @brief  Perform the hashing algorithm on a current_block of data.
        constexpr void hash_block() {
            unsigned int A = pack_big_endian(&this->current_hash.data[0 * 4]);
            unsigned int B = pack_big_endian(&this->current_hash.data[1 * 4]);
            unsigned int C = pack_big_endian(&this->current_hash.data[2 * 4]);
            unsigned int D = pack_big_endian(&this->current_hash.data[3 * 4]);
            unsigned int E = pack_big_endian(&this->current_hash.data[4 * 4]);

            // Fill the start of the working block from the current block.
            unsigned int working_block[80] = {};
            for (unsigned int index = 0; index < sha1::block_size / sizeof(unsigned int); ++index) {
                working_block[index] = pack_big_endian(&this->current_block.data[index * 4]);
            }

            // Mix to fill the remainder of the working block.
            for (unsigned int index = sha1::block_size / sizeof(unsigned int); index < 80; ++index) {
                // This line's addition of a 1 bit left rotate is the only change from sha0.
                working_block[index] = rotate_left((working_block[index - 3] ^ working_block[index - 8] ^ working_block[index - 14] ^ working_block[index - 16]), 1);
            }

            // Do the hash iterations.
            for (unsigned int iteration = 0; iteration < this->processing_rounds; ++iteration) {
                unsigned int F = 0;
                unsigned int K = 0;

                if (iteration < 20) {
                    F = (B & C) | (~B & D);
                    K = 0x5A827999;
                }
                else if (iteration < 40) {
                    F = B ^ C ^ D;
                    K = 0x6ED9EBA1;
                }
                else if (iteration < 60) {
                    F = (B & C) | (B & D) | (C & D);
                    K = 0x8F1BBCDC;
                }
                else {
                    F = B ^ C ^ D;
                    K = 0xCA62C1D6;
                }

                unsigned int next_A = rotate_left(A, 5) + F + E + K + working_block[iteration];
                E = D;
                D = C;
                C = rotate_left(B, 30);
                B = A;
                A = next_A;
            }

            unpack_big_endian(pack_big_endian(&this->current_hash.data[0 * 4]) + A, &this->current_hash.data[0 * 4]);
            unpack_big_endian(pack_big_endian(&this->current_hash.data[1 * 4]) + B, &this->current_hash.data[1 * 4]);
            unpack_big_endian(pack_big_endian(&this->current_hash.data[2 * 4]) + C, &this->current_hash.data[2 * 4]);
            unpack_big_endian(pack_big_endian(&this->current_hash.data[3 * 4]) + D, &this->current_hash.data[3 * 4]);
            unpack_big_endian(pack_big_endian(&this->current_hash.data[4 * 4]) + E, &this->current_hash.data[4 * 4]);
        }

    public:
        /// @brief  Reset the internal state of the current_hash.
        constexpr void reset() {
            this->hashed_length = 0;
            this->current_block = {};
            this->current_hash = {};
            this->finalised = false;
        }

        /// @brief  Consume data, constructing blocks and hashing as needed.
        /// @param  data Input data pointer.
        /// @param  length Valid length of the input data pointer.
        constexpr void consume(const char* data, unsigned long long int length) {
            GTL_SHA1_ASSERT(this->finalised == false, "Finalise must not be called before consume().");
            GTL_SHA1_ASSERT(this->hashed_length <= this->hashed_length + length, "Total hashed data must be less than 2^64 bytes.");

            // Count how much data has been consumed.
            this->hashed_length += length;

            // Block construction and processing.
            while (length--) {
                // Append data to the current block.
                this->current_block.data[this->current_block.length_bytes++] = static_cast<unsigned char>(*data++);

                // If full, hash.
                if (this->current_block.length_bytes == sha1::block_size) {
                    this->hash_block();
                    this->current_block = {};
                }
            }
        }

        /// @brief  Finishes processing any remaining buffered data.
        constexpr void finalise() {
            GTL_SHA1_ASSERT(this->finalised == false, "Finalise must not be called before finalise().");

            // Pad the data with a single 0x80 on the end.
            this->current_block.data[this->current_block.length_bytes++] = static_cast<unsigned char>(0x80);

            // Check if there is enough space in the final chunk for the data length.
            if (this->current_block.length_bytes > (sha1::block_size - sizeof(unsigned long long int))) {
                this->hash_block();
                this->current_block = {};
            }

            // Add the data length to the chunk.
            const unsigned long long int hashed_length_bits = this->hashed_length * 8;
            unpack_big_endian((hashed_length_bits >> 32) & 0xFFFFFFFF, &this->current_block.data[sha1::block_size - 8]);
            unpack_big_endian((hashed_length_bits >> 0) & 0xFFFFFFFF, &this->current_block.data[sha1::block_size - 4]);

            // Hash the block.
            this->hash_block();

            this->finalised = true;
        }

        /// @brief  Calculate the final current_hash from the state and return it.
        /// @return The resultant current_hash.
        constexpr const hash_type& get_hash() const {
            GTL_SHA1_ASSERT(this->finalised == true, "Finalise must be called before get_hash().");
            return this->current_hash;
        }

    public:
        /// @brief  Simple type to hold the string representation of the hash.
        struct hash_string_type final {
            char hash[(sha1::hash_size * 2) + 1] = {};
        };

        /// @brief  Convert a hash into its string representation.
        /// @param  hash The hash to convert.
        /// @return The string representation of the hash, with null termination.
        constexpr static hash_string_type hash_to_string(const hash_type& hash) {
            hash_string_type output;
            constexpr const char* hex_characters = "0123456789ABCDEF";
            for (unsigned int index = 0u; index < (sha1::hash_size * 2); ++index) {
                output.hash[index] = hex_characters[(hash.data[index / 2] >> ((1 - (index % 2)) * 4)) & 0xF];
            }
            output.hash[sha1::hash_size * 2] = 0;
            return output;
        }

    public:
        /// @brief  Hash a buffer of data.
        /// @param  data Input data pointer.
        /// @param  length Valid length of the input data pointer.
        static hash_type hash(const char* data, const unsigned long long int length) {
            sha1 hash_function;
            hash_function.reset();
            hash_function.consume(data, length);
            hash_function.finalise();
            return hash_function.get_hash();
        }
    };
}

#undef GTL_SHA1_ASSERT

#endif // GTL_HASH_SHA1_HPP
