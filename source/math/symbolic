/*
The MIT License
Copyright (c) 2019 Geoffrey Daniels. http://gpdaniels.com/
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE
*/

#pragma once
#ifndef GTL_SYMBOLIC_HPP
#define GTL_SYMBOLIC_HPP

// Summary: Compile time symbolic differentiation using template metaprogramming. [wip]

#if defined(_MSC_VER)
#   pragma warning(push, 0)
#endif

#include <algorithm>
#include <cmath>
#include <string>
#include <vector>

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

namespace gtl {
namespace symbolic {
    ///////////////////////////////////////////////////////////////////////////
    /// Parameters / Variables / Constants.
    ///////////////////////////////////////////////////////////////////////////

    template <
        unsigned long long int parameter_index
    >
    class parameter final {
    public:
        constexpr inline parameter() = default;
    public:
        template <
            typename scalar_type,
            typename value_type,
            typename... value_types
        >
        constexpr static inline scalar_type solve(
            value_type value,
            value_types... values
        ) {
            if constexpr(parameter_index != 0) {
                return parameter<parameter_index - 1>::template solve<scalar_type>(values...);
            }
            return static_cast<scalar_type>(value);
        }
    public:
        static inline std::string to_string(
        ) {
            return "param[" + std::to_string(parameter_index) + "]";
        }
    };

    template <
        unsigned long long int variable_index
    >
    class variable final {
    public:
        constexpr inline variable() = default;
    public:
        template <
            typename scalar_type,
            typename value_type,
            typename... value_types
        >
        constexpr static inline scalar_type solve(
            value_type value,
            value_types... values
        ) {
            if constexpr(variable_index != 0) {
                return parameter<variable_index - 1>::template solve<scalar_type>(values...);
            }
            return static_cast<scalar_type>(value);
        }
    public:
        static inline std::string to_string(
        ) {
            return "const[" + std::to_string(variable_index) + "]";
        }
    };

    template <
        typename constant_type
    >
    class constant final {
    public:
        using type = constant_type;
    public:
        constexpr inline constant() = default;
    public:
        template <
            typename scalar_type,
            typename... value_types
        >
        constexpr static inline scalar_type solve(
            value_types... values
        ) {
            (static_cast<void>(values), ...);
            return static_cast<scalar_type>(constant_type::value);
        }
    public:
        static inline std::string to_string(
        ) {
            return std::to_string(constant_type::value);
        }
    };

    ///////////////////////////////////////////////////////////////////////////
    /// Missing Operations.
    ///////////////////////////////////////////////////////////////////////////

    namespace missing_operations {
        template <
            typename argument_type
        >
        constexpr inline auto plus(
            argument_type value
        ) {
            return +value;
        }

        template <
            typename argument_type
        >
        constexpr inline auto minus(
            argument_type value
        ) {
            return -value;
        }

        template <
            typename... argument_types
        >
        constexpr inline auto add(
            argument_types... values
        ) {
            return (values + ...);
        }

        template <
            typename... argument_types
        >
        constexpr inline auto subtract(
            argument_types... values
        ) {
            return (values - ...);
        }

        template <
            typename... argument_types
        >
        constexpr inline auto multiply(
            argument_types... values
            ) {
            return (values * ...);
        }

        template <
            typename... argument_types
        >
        constexpr inline auto divide(
            argument_types... values
        ) {
            return (values / ...);
        }

        template <
            typename argument_type
        >
        constexpr int sign(
            argument_type value
        ) {
            return (argument_type(0) < value) - (value < argument_type(0));
        }

        template <
            typename argument_type
        >
        constexpr argument_type abs(
            argument_type value
        ) {
            //if (value == argument_type(0)) {
            //    return argument_type(0);
            //}
            if (value < argument_type(0)) {
                return -value;
            }
            return value;
        }

        // https://github.com/elbeno/constexpr/blob/master/src/include/cx_math.h
        // https://github.com/a2flo/floor/blob/master/constexpr/const_math.hpp
        // https://github.com/kthohr/gcem

        //TODO: This does not work for large or small numbers.
        template <
            typename argument_type
        >
        constexpr argument_type ceil(
            argument_type value
        ) {
            // Casting to fixed point truncates the value, which is ceil(value) for negative values.
            // Have to add 1 for positive values unless value is already ceiled.
            return static_cast<long long int>(value) + (value == static_cast<argument_type>(static_cast<long long int>(value))) * (value > 0);
        }

        //TODO: This does not work for large or small numbers.
        template <
            typename argument_type
        >
        constexpr argument_type floor(
            argument_type value
        ) {
            // Casting to fixed point truncates the value, which is floor(value) for positive values.
            // Have to substract 1 for negative values unless value is already floored.
            return static_cast<long long int>(value) - (value == static_cast<argument_type>(static_cast<long long int>(value))) * (value < 0);
        }

        template <
            typename argument_type
        >
        constexpr argument_type min(
            argument_type lhs_value,
            argument_type rhs_value
        ) {
            if (lhs_value < rhs_value) {
                return lhs_value;
            }
            return rhs_value;
        }

        template <
            typename argument_type
        >
        constexpr argument_type max(
            argument_type lhs_value,
            argument_type rhs_value
        ) {
            if (lhs_value < rhs_value) {
                return rhs_value;
            }
            return lhs_value;
        }
    }

    ///////////////////////////////////////////////////////////////////////////
    /// Constant number types.
    ///////////////////////////////////////////////////////////////////////////

    template <
        int constant_value
    >
    class integer final {
    public:
        constexpr inline integer() = default;
    public:
        constexpr static inline int value = constant_value;
    };

    template <
        int constant_value
    >
    inline constexpr auto operator+(
        const integer<constant_value> value
    ) {
        static_cast<void>(value);
        return integer<constant_value>{};
    }

    template <
        int constant_value
    >
    inline constexpr auto operator-(
        const integer<constant_value> value
    ) {
        static_cast<void>(value);
        return integer<-constant_value>{};
    }

    template <
        int constant_value,
        int other_value
    >
    inline constexpr auto operator+(
        const integer<constant_value> lhs,
        const integer<other_value> rhs
    ) {
        static_cast<void>(lhs);
        static_cast<void>(rhs);
        return integer<constant_value + other_value>{};
    }

    template <
        int constant_value,
        int other_value
    >
    inline constexpr auto operator-(
        const integer<constant_value> lhs,
        const integer<other_value> rhs
    ) {
        static_cast<void>(lhs);
        static_cast<void>(rhs);
        return integer<constant_value - other_value>{};
    }

    template <
        int constant_value,
        int other_value
    >
    inline constexpr auto operator*(
        const integer<constant_value> lhs,
        const integer<other_value> rhs
    ) {
        static_cast<void>(lhs);
        static_cast<void>(rhs);
        return integer<constant_value * other_value>{};
    }

    template <
        int constant_value,
        int other_value
    >
    inline constexpr auto operator/(
        const integer<constant_value> lhs,
        const integer<other_value> rhs
    ) {
        static_cast<void>(lhs);
        static_cast<void>(rhs);
        return integer<constant_value / other_value>{};
    }

    template <
        int constant_value
    >
    auto sign(
        const integer<constant_value> value
    ) {
        static_cast<void>(value);
        return integer<missing_operations::sign(constant_value)>{};
    }

    template <
        int constant_value
    >
    auto abs(
        const integer<constant_value> value
    ) {
        static_cast<void>(value);
        return integer<missing_operations::abs(constant_value)>{};
    }

    template <
        int constant_value,
        int other_value
    >
    auto min(
        const integer<constant_value> lhs,
        const integer<other_value> rhs
    ) {
        static_cast<void>(lhs);
        static_cast<void>(rhs);
        return integer<missing_operations::min(constant_value, other_value)>{};
    }

    template <
        int constant_value,
        int other_value
    >
    auto max(
        const integer<constant_value> lhs,
        const integer<other_value> rhs
    ) {
        static_cast<void>(lhs);
        static_cast<void>(rhs);
        return integer<missing_operations::max(constant_value, other_value)>{};
    }

    using minus_three = constant<integer<-3>>;
    using minus_two = constant<integer<-2>>;
    using minus_one = constant<integer<-1>>;
    using zero = constant<integer<0>>;
    using one = constant<integer<1>>;
    using two = constant<integer<2>>;
    using three = constant<integer<3>>;

    template<
        signed long long int whole,
        unsigned long long int decimal,
        unsigned long long int exponent
    >
    class real final {
    public:
        constexpr static float pow10(int e) {
            return e == 0 ? 1.0f : e > 0 ? 10.0f * pow10(e - 1) : 0.1f * pow10(e + 1);
        }

        constexpr static float log10(int e) {
            // TODO: This is definitely not right...
            static_cast<void>(e);
            return 1;
        }

        constexpr static const float value = (whole + (decimal / log10(decimal))) * pow10(exponent);
    };

    template<
        bool sign,
        unsigned int mantissa,
        unsigned int exponent
    >
    class real_float final {
    public:
# if 0
        constexpr float abs(float x) { return x<0 ? -x : x; }

        constexpr int get_exponent(float x) {
            return abs(x) >= 2 ? get_exponent(x / 2) + 1 : abs(x) < 1 ? get_exponent(x * 2) - 1 : 0;
        }

        // Multiplies a floating point value x by FLT_RADIX raised to power exp.
        constexpr float get_scalbn(float value, int exp) {
            return exp == 0 ? value : exp > 0 ? get_scalbn(value * 2, exp - 1) : get_scalbn(value / 2, exp + 1);
        }

        constexpr unsigned get_mantissa(float x) {
            // remove hidden 1 and bias the exponent to get integer
            return abs(x) < std::numeric_limits<float>::infinity() ? scalbn(scalbn(abs(x), -get_exponent(x)) - 1, 23) : 0;
        }
#endif
        constexpr static float pow2(int e) {
            return e == 0 ? 1.0f : e > 0 ? 2.0f * pow2(e - 1) : 0.5f * pow2(e + 1);
        }

        constexpr static const float value = (sign ? -1.0f : 1.0f) * mantissa * pow2(exponent);
    };

    ///////////////////////////////////////////////////////////////////////////
    /// Template metaprograms.
    ///////////////////////////////////////////////////////////////////////////

    template<
        typename lhs_type,
        typename rhs_type
    >
    class is_same_type_test final {
    public:
        constexpr static const bool value = false;
    };

    template<
        typename type
    >
    class is_same_type_test<type, type> final {
    public:
        constexpr static const bool value = true;
    };

    template<
        typename lhs_type,
        typename rhs_type
    >
    constexpr static const bool is_same_type = is_same_type_test<lhs_type, rhs_type>::value;

    ///////////////////////////////////////////////////////////////////////////

    template<
        typename type
    >
    class is_parameter_type_test final {
    public:
        constexpr static const bool value = false;
    };

    template<
        unsigned long long int parameter_index
    >
    class is_parameter_type_test<parameter<parameter_index>> final {
    public:
        constexpr static const bool value = true;
    };

    template<
        typename type
    >
    constexpr static const bool is_parameter_type = is_parameter_type_test<type>::value;

    ///////////////////////////////////////////////////////////////////////////

    template<
        typename type
    >
    class is_variable_type_test final {
    public:
        constexpr static const bool value = false;
    };

    template<
        unsigned long long int variable_index
    >
    class is_variable_type_test<variable<variable_index>> final {
    public:
        constexpr static const bool value = true;
    };

    template<
        typename type
    >
    constexpr static const bool is_variable_type = is_variable_type_test<type>::value;

    ///////////////////////////////////////////////////////////////////////////

    template<
        typename type
    >
    class is_constant_type_test final {
    public:
        constexpr static const bool value = false;
    };

    template<
        typename constant_type
    >
    class is_constant_type_test<constant<constant_type>> final {
    public:
        constexpr static const bool value = true;
    };

    template<
        typename type
    >
    constexpr static const bool is_constant_type = is_constant_type_test<type>::value;

    ///////////////////////////////////////////////////////////////////////////

    template<
        typename type
    >
    constexpr static const bool is_input_type = is_parameter_type<type> || is_variable_type<type> || is_constant_type<type>;

    ///////////////////////////////////////////////////////////////////////////

    template <
        typename operation_handler,
        typename... argument_types
    >
    class operation;

    template<
        typename type
    >
    class is_operation_type_test final {
    public:
        constexpr static const bool value = false;
    };

    template<
        typename operation_type,
        typename... argument_types
    >
    class is_operation_type_test<operation<operation_type, argument_types...>> final {
    public:
        constexpr static const bool value = true;
    };

    template<
        typename operation_type
    >
    class is_operation_type_test<operation<operation_type>> final {
    public:
        constexpr static const bool value = false;
    };

    ///////////////////////////////////////////////////////////////////////////

    template<
        typename type
    >
    constexpr static const bool is_operation_type = is_operation_type_test<type>::value;

    ///////////////////////////////////////////////////////////////////////////

    template<
        typename type
    >
    constexpr static const bool is_symbolic_type = is_input_type<type> || is_operation_type<type>;

    ///////////////////////////////////////////////////////////////////////////
    /// Operations.
    ///////////////////////////////////////////////////////////////////////////

    template <
        typename operation_handler,
        typename... argument_types
    >
    class operation final {
    private:
        static_assert((is_symbolic_type<argument_types> && ...), "All arguments must be symbolic types.");
    public:
        constexpr inline operation() = default;
    public:
        template <
            typename scalar_type,
            typename... value_types
        >
        constexpr static inline scalar_type solve(
            value_types... values
        ) {
            return operation_handler::template apply<scalar_type>(argument_types::template solve<scalar_type>(values...)...);
        }
    public:
        static inline std::string to_string(
        ) {
            std::string argument_strings[] = { argument_types::to_string()... };
            std::string result = std::string(operation_handler::to_string()) + "(";
            for (std::size_t argument_index = 0; argument_index < sizeof...(argument_types); ++argument_index) {
                if (argument_index > 0) {
                    result += ",";
                }
                result += argument_strings[argument_index];
            }
            result += ")";
            return result;
        }
    };

    #define GTL_DEFINE_OPERATION_HANDLER(                                                           \
        OPERATION,                                                                                  \
        FUNCTION                                                                                    \
    )                                                                                               \
        class OPERATION ## _handler final {                                                         \
        public:                                                                                     \
            constexpr inline OPERATION ## _handler() = default;                                     \
        public:                                                                                     \
            template <                                                                              \
                typename scalar_type,                                                               \
                typename... value_types                                                             \
            >                                                                                       \
            constexpr static inline scalar_type apply(                                              \
                const value_types... values                                                         \
            ) {                                                                                     \
                return static_cast<scalar_type>(FUNCTION);                                          \
            }                                                                                       \
        public:                                                                                     \
            static inline const char* to_string(                                                    \
            ) {                                                                                     \
                return #OPERATION;                                                                  \
            }                                                                                       \
        };                                                                                          \
                                                                                                    \
        template <                                                                                  \
            typename... argument_types                                                              \
        >                                                                                           \
        using OPERATION ## _op = operation<                                                         \
                OPERATION ## _handler,                                                              \
                argument_types...                                                                   \
            >;                                                                                      \

    GTL_DEFINE_OPERATION_HANDLER(plus,     missing_operations::plus(values...))
    GTL_DEFINE_OPERATION_HANDLER(minus,    missing_operations::minus(values...))
    GTL_DEFINE_OPERATION_HANDLER(add,      missing_operations::add(values...))
    GTL_DEFINE_OPERATION_HANDLER(subtract, missing_operations::subtract(values...))
    GTL_DEFINE_OPERATION_HANDLER(multiply, missing_operations::multiply(values...))
    GTL_DEFINE_OPERATION_HANDLER(divide,   missing_operations::divide(values...))

    #define GTL_DEFINE_OPERATION_UNARY_OPERATOR(                                                    \
        OPERATION,                                                                                  \
        SYMBOL                                                                                      \
    )                                                                                               \
        template <                                                                                  \
            typename argument_type,                                                                 \
            typename... argument_types                                                              \
        >                                                                                           \
        constexpr inline OPERATION ## _op<                                                          \
            argument_type                                                                           \
        >                                                                                           \
        operator SYMBOL(                                                                            \
            argument_type argument                                                                  \
        ) {                                                                                         \
            static_cast<void>(argument);                                                            \
            return OPERATION ## _op<                                                                \
                argument_type                                                                       \
            >{};                                                                                    \
        }                                                                                           \

    #define GTL_DEFINE_OPERATION_NARY_OPERATOR(                                                     \
        OPERATION,                                                                                  \
        SYMBOL                                                                                      \
    )                                                                                               \
        template <                                                                                  \
            typename argument_type,                                                                 \
            typename... argument_types                                                              \
        >                                                                                           \
        constexpr inline OPERATION ## _op<                                                          \
            argument_type,                                                                          \
            argument_types...                                                                       \
        >                                                                                           \
        operator SYMBOL(                                                                            \
            argument_type argument,                                                                 \
            argument_types... arguments                                                             \
        ) {                                                                                         \
            static_cast<void>(argument);                                                            \
            (static_cast<void>(arguments), ...);                                                    \
            return OPERATION ## _op<                                                                \
                argument_type,                                                                      \
                argument_types...                                                                   \
            >{};                                                                                    \
        }                                                                                           \

    GTL_DEFINE_OPERATION_UNARY_OPERATOR(plus, +)
    GTL_DEFINE_OPERATION_UNARY_OPERATOR(minus, -)

    GTL_DEFINE_OPERATION_NARY_OPERATOR(add, +)
    GTL_DEFINE_OPERATION_NARY_OPERATOR(subtract, -)
    GTL_DEFINE_OPERATION_NARY_OPERATOR(multiply, *)
    GTL_DEFINE_OPERATION_NARY_OPERATOR(divide, /)

    #define GTL_DEFINE_OPERATION_OVERLOAD(                                                          \
        OPERATION                                                                                   \
    )                                                                                               \
        template <                                                                                  \
            typename... argument_types                                                              \
        >                                                                                           \
        constexpr inline operation<                                                                 \
            OPERATION ## _handler,                                                                  \
            argument_types...                                                                       \
        > OPERATION(const argument_types&... arguments) {                                           \
            (static_cast<void>(arguments), ...);                                                    \
            return operation<                                                                       \
                OPERATION ## _handler,                                                              \
                argument_types...                                                                   \
            >{};                                                                                    \
        }                                                                                           \

    GTL_DEFINE_OPERATION_HANDLER(sign, missing_operations::sign(values...))
    GTL_DEFINE_OPERATION_OVERLOAD(sign)

    GTL_DEFINE_OPERATION_HANDLER(abs, missing_operations::abs(values...))
    GTL_DEFINE_OPERATION_OVERLOAD(abs)

    GTL_DEFINE_OPERATION_HANDLER(ceil, std::ceil(values...))
    GTL_DEFINE_OPERATION_OVERLOAD(ceil)
    GTL_DEFINE_OPERATION_HANDLER(floor, std::floor(values...))
    GTL_DEFINE_OPERATION_OVERLOAD(floor)

    GTL_DEFINE_OPERATION_HANDLER(exp, std::exp(values...))
    GTL_DEFINE_OPERATION_OVERLOAD(exp)
    GTL_DEFINE_OPERATION_HANDLER(log, std::log(values...))
    GTL_DEFINE_OPERATION_OVERLOAD(log)

    GTL_DEFINE_OPERATION_HANDLER(exp2, std::exp2(values...))
    GTL_DEFINE_OPERATION_OVERLOAD(exp2)
    GTL_DEFINE_OPERATION_HANDLER(log2, std::log2(values...))
    GTL_DEFINE_OPERATION_OVERLOAD(log2)

    GTL_DEFINE_OPERATION_HANDLER(sin, std::sin(values...))
    GTL_DEFINE_OPERATION_OVERLOAD(sin)
    GTL_DEFINE_OPERATION_HANDLER(asin, std::asin(values...))
    GTL_DEFINE_OPERATION_OVERLOAD(asin)

    GTL_DEFINE_OPERATION_HANDLER(cos, std::cos(values...))
    GTL_DEFINE_OPERATION_OVERLOAD(cos)
    GTL_DEFINE_OPERATION_HANDLER(acos, std::acos(values...))
    GTL_DEFINE_OPERATION_OVERLOAD(acos)

    GTL_DEFINE_OPERATION_HANDLER(tan, std::tan(values...))
    GTL_DEFINE_OPERATION_OVERLOAD(tan)
    GTL_DEFINE_OPERATION_HANDLER(atan, std::atan(values...))
    GTL_DEFINE_OPERATION_OVERLOAD(atan)

    GTL_DEFINE_OPERATION_HANDLER(sinh, std::sinh(values...))
    GTL_DEFINE_OPERATION_OVERLOAD(sinh)
    GTL_DEFINE_OPERATION_HANDLER(asinh, std::asinh(values...))
    GTL_DEFINE_OPERATION_OVERLOAD(asinh)

    GTL_DEFINE_OPERATION_HANDLER(cosh, std::cosh(values...))
    GTL_DEFINE_OPERATION_OVERLOAD(cosh)
    GTL_DEFINE_OPERATION_HANDLER(acosh, std::acosh(values...))
    GTL_DEFINE_OPERATION_OVERLOAD(acosh)

    GTL_DEFINE_OPERATION_HANDLER(tanh, std::tanh(values...))
    GTL_DEFINE_OPERATION_OVERLOAD(tanh)
    GTL_DEFINE_OPERATION_HANDLER(atanh, std::atanh(values...))
    GTL_DEFINE_OPERATION_OVERLOAD(atanh)

    GTL_DEFINE_OPERATION_HANDLER(sqrt, std::sqrt(values...))
    GTL_DEFINE_OPERATION_OVERLOAD(sqrt)
    GTL_DEFINE_OPERATION_HANDLER(cbrt, std::cbrt(values...))
    GTL_DEFINE_OPERATION_OVERLOAD(cbrt)

    GTL_DEFINE_OPERATION_HANDLER(min, missing_operations::min(values...))
    GTL_DEFINE_OPERATION_OVERLOAD(min)
    GTL_DEFINE_OPERATION_HANDLER(max, missing_operations::max(values...))
    GTL_DEFINE_OPERATION_OVERLOAD(max)

    GTL_DEFINE_OPERATION_HANDLER(hypot, std::hypot(values...))
    GTL_DEFINE_OPERATION_OVERLOAD(hypot)
    GTL_DEFINE_OPERATION_HANDLER(atan2, std::atan2(values...))
    GTL_DEFINE_OPERATION_OVERLOAD(atan2)

    GTL_DEFINE_OPERATION_HANDLER(pow, std::pow(values...))
    GTL_DEFINE_OPERATION_OVERLOAD(pow)

    ///////////////////////////////////////////////////////////////////////////
    /// Simplification.
    ///////////////////////////////////////////////////////////////////////////

    template <
        unsigned long long int parameter_index
    >
    constexpr auto simplify_expression(
        parameter<parameter_index> value
    ) {
        return value;
    }

    template <
        unsigned long long int variable_index
    >
    constexpr auto simplify_expression(
        variable<variable_index> value
    ) {
        return value;
    }

    template <
        typename constant_type
    >
    constexpr auto simplify_expression(
        constant<constant_type> value
    ) {
        return value;
    }

    ///////////////////////////////////////////////////////////////////////////

    template<
        typename... argument_types
    >
    class argument_pack;

    template<
        typename argument_type,
        typename... argument_types
    >
    class argument_pack<argument_type, argument_types...> final {
    private:
        static_assert(is_symbolic_type<argument_type> && (is_symbolic_type<argument_types> && ...), "All arguments of an argument pack must be symbolic types.");
    public:
        using first = argument_type;
        using remaining = argument_pack<argument_types...>;
    public:
        static std::vector<std::string> to_strings(
        ) {
            std::vector<std::string> result;
            result.push_back(first::to_string());
            std::vector<std::string> result_remaining = remaining::to_strings();
            result.insert(std::end(result), std::begin(result_remaining), std::end(result_remaining));
            return result;
        }
    };

    template<
    >
    class argument_pack<> final {
    public:
        static std::vector<std::string> to_strings(
        ) {
            return {};
        }
    };

    template<
        typename... argument_types
    >
    using argument_first = typename argument_pack<argument_types...>::first;

    ///////////////////////////////////////////////////////////////////////////

    template<typename... argument_types>
    constexpr inline auto simplifier_stages() {
        static_assert((is_symbolic_type<argument_types> && ...), "All arguments must be symbolic types.");
        return argument_pack<argument_types...>{};
    }

    template<typename... argument_types, typename function_stage_type, typename... function_stage_types>
    constexpr inline auto simplifier_stages(function_stage_type function_stage, function_stage_types... function_stages) {
        static_assert((is_symbolic_type<argument_types> && ...), "All arguments must be symbolic types.");
        auto simplified = function_stage();
        if constexpr(is_same_type<argument_pack<argument_types...>, decltype(simplified)>) {
            return simplifier_stages<argument_types...>(function_stages...);
        }
        else {
            return simplified;
        }
    }

    ///////////////////////////////////////////////////////////////////////////

    template<typename... function_types>
    class function_collection final
        : function_types... {
    public:
        constexpr inline function_collection(
            function_types... functions
        ) : function_types{functions}... {
        }
    public:
        using function_types::operator()...;
    };

    // Template argument deduction guide.
    template<typename... function_types>
    function_collection(
        function_types... functions
    ) -> function_collection<function_types...>;

    ///////////////////////////////////////////////////////////////////////////

    template<
        typename... argument_types_lhs,
        typename... argument_types_rhs,
        typename... argument_pack_types
    >
    constexpr auto merge_argument_packs(
        argument_pack<argument_types_lhs...> pack_lhs,
        argument_pack<argument_types_rhs...> pack_rhs,
        argument_pack_types... packs
    ) {
        static_assert((is_symbolic_type<argument_types_lhs> && ...), "All arguments must be symbolic types.");
        static_assert((is_symbolic_type<argument_types_rhs> && ...), "All arguments must be symbolic types.");
        static_cast<void>(pack_lhs);
        static_cast<void>(pack_rhs);
        (static_cast<void>(packs), ...);
        return merge_argument_packs(argument_pack<argument_types_lhs..., argument_types_rhs...>{}, argument_pack_types{}...);
    }

    template<
        typename... argument_types
    >
    constexpr auto merge_argument_packs(
        argument_pack<argument_types...> pack
    ) {
        static_assert((is_symbolic_type<argument_types> && ...), "All arguments must be symbolic types.");
        static_cast<void>(pack);
        return argument_pack<argument_types...>{};
    }

    constexpr auto merge_argument_packs(
    ) {
        return argument_pack<>{};
    }

    ///////////////////////////////////////////////////////////////////////////

    template<
        typename... argument_types,
        typename... function_types
    >
    constexpr auto simplify_argument(
        function_types... functions
    ) {
        static_assert((is_symbolic_type<argument_types> && ...), "All arguments must be symbolic types.");
        return merge_argument_packs(
            function_collection{functions...}(
                argument_types{}
            ) ...);
    }

    template<
        typename... argument_types,
        typename... function_types
    >
    constexpr auto simplify_argument_pair(
        function_types... functions
    ) {
        static_assert((is_symbolic_type<argument_types> && ...), "All arguments must be symbolic types.");
        return merge_argument_packs(
            function_collection{functions...}(
                typename argument_pack<argument_types...>::first{},
                typename argument_pack<argument_types...>::remaining::first{}
            ),
            typename argument_pack<argument_types...>::remaining::remaining{}
        );
    }

    ///////////////////////////////////////////////////////////////////////////

    template<
        typename operation_type,
        typename... argument_types
    >
    constexpr inline auto operation_from_argument_pack(
        operation_type op,
        argument_pack<argument_types...> pack
    ) {
        static_assert((is_symbolic_type<argument_types> && ...), "All arguments must be symbolic types.");
        static_cast<void>(op);
        static_cast<void>(pack);
        return operation<operation_type, argument_types...>{};
    }

    ///////////////////////////////////////////////////////////////////////////

    template<
        typename argument_type
    >
    constexpr auto simplify_expression(
        plus_op<argument_type> op
    ) {
        static_assert(is_symbolic_type<argument_type>, "All arguments must be symbolic types.");
        static_cast<void>(op);
        if constexpr (is_same_type<argument_type, zero>) {
            return zero{};
        }
        else if constexpr (is_constant_type<argument_type>) {
            return constant<decltype(+typename argument_type::type{})>{};
        }
        else {
            return plus_op<decltype(simplify_expression(argument_type{}))>{};
        }
    }

    template<
        typename argument_type
    >
    constexpr auto simplify_expression(
        minus_op<argument_type> op
    ) {
        static_assert(is_symbolic_type<argument_type>, "All arguments must be symbolic types.");
        static_cast<void>(op);
        if constexpr (is_same_type<argument_type, zero>) {
            return zero{};
        }
        else if constexpr (is_constant_type<argument_type>) {
            return constant<decltype(-typename argument_type::type{})>{};
        }
        else {
            return minus_op<decltype(simplify_expression(argument_type{}))>{};
        }
    }

    template<
        typename... argument_types
    >
    constexpr auto simplify_expression(
        add_op<argument_types...> op
    ) {
        static_assert((is_symbolic_type<argument_types> && ...), "All arguments must be symbolic types.");
        static_cast<void>(op);
        if constexpr (sizeof...(argument_types) == 0) {
            return zero{};
        }
        else if constexpr (sizeof...(argument_types) == 1) {
            return argument_first<argument_types...>{};
        }
        else {
            return operation_from_argument_pack(
                add_handler{},
                simplifier_stages<argument_types...>(
                    []() {
                        return simplify_argument<argument_types...>(
                            [](zero argument){
                                static_cast<void>(argument);
                                return argument_pack<>{};
                            },
                            [](auto argument){
                                return argument_pack<decltype(simplify_expression(argument))>{};
                            }
                        );
                    },
                    [](){
                        return simplify_argument_pair<argument_types...>(
                            [](auto lhs, auto rhs) {
                                if constexpr (is_constant_type<decltype(lhs)> && is_constant_type<decltype(rhs)>) {
                                    return argument_pack<constant<decltype(typename decltype(lhs)::type{} + typename decltype(rhs)::type{})>>{};
                                }
                                else if constexpr (is_same_type<decltype(lhs), decltype(rhs)>) {
                                    return argument_pack<multiply_op<two, decltype(lhs)>>{};
                                }
                                else {
                                    return argument_pack<decltype(simplify_expression(lhs)), decltype(simplify_expression(rhs))>{};
                                }
                            }
                        );
                    }
                )
            );
        }
    }

    template<
        typename... argument_types
    >
    constexpr auto simplify_expression(
        subtract_op<argument_types...> op
    ) {
        static_assert((is_symbolic_type<argument_types> && ...), "All arguments must be symbolic types.");
        static_cast<void>(op);
        if constexpr (sizeof...(argument_types) == 0) {
            return zero{};
        }
        else if constexpr (sizeof...(argument_types) == 1) {
            return argument_first<argument_types...>{};
        }
        else {
            return operation_from_argument_pack(
                subtract_handler{},
                simplifier_stages<argument_types...>(
                    []() {
                        return simplify_argument<argument_types...>(
                            [](auto argument){
                                return argument_pack<decltype(simplify_expression(argument))>{};
                            }
                        );
                    },
                    [](){
                        return simplify_argument_pair<argument_types...>(
                            [](auto lhs, auto rhs) {
                                if constexpr (is_same_type<decltype(lhs), decltype(rhs)>) {
                                    return argument_pack<zero>{};
                                }
                                else if constexpr (is_same_type<zero, decltype(rhs)>) {
                                    return argument_pack<decltype(lhs)>{};
                                }
                                else if constexpr (is_constant_type<decltype(lhs)> && is_constant_type<decltype(rhs)>) {
                                    return argument_pack<constant<decltype(typename decltype(lhs)::type{} - typename decltype(rhs)::type{})>>{};
                                }
                                else {
                                    return argument_pack<decltype(simplify_expression(lhs)), decltype(simplify_expression(rhs))>{};
                                }
                            }
                        );
                    }
                )
            );
        }
    }

    template<
        typename... argument_types
    >
    constexpr auto simplify_expression(
        multiply_op<argument_types...> op
    ) {
        static_assert((is_symbolic_type<argument_types> && ...), "All arguments must be symbolic types.");
        static_cast<void>(op);
        if constexpr (sizeof...(argument_types) == 0) {
            return zero{};
        }
        else if constexpr (sizeof...(argument_types) == 1) {
            return argument_first<argument_types...>{};
        }
        else {
            return operation_from_argument_pack(
                multiply_handler{},
                simplifier_stages<argument_types...>(
                    []() {
                        return simplify_argument<argument_types...>(
                            [](one argument){
                                static_cast<void>(argument);
                                return argument_pack<>{};
                            },
                            [](auto argument){
                                return argument_pack<decltype(simplify_expression(argument))>{};
                            }
                        );
                    },
                    [](){
                        return simplify_argument_pair<argument_types...>(
                            [](auto lhs, auto rhs) {
                                if constexpr (is_same_type<decltype(lhs), zero> || is_same_type<zero, decltype(rhs)>) {
                                    return argument_pack<zero>{};
                                }
                                else if constexpr (is_constant_type<decltype(lhs)> && is_constant_type<decltype(rhs)>) {
                                    return argument_pack<constant<decltype(typename decltype(lhs)::type{} * typename decltype(rhs)::type{})>>{};
                                }
                                else if constexpr (is_same_type<decltype(lhs), decltype(rhs)>) {
                                    return argument_pack<pow_op<decltype(lhs), two>>{};
                                }
                                else {
                                    return argument_pack<decltype(simplify_expression(lhs)), decltype(simplify_expression(rhs))>{};
                                }
                            }
                        );
                    }
                )
            );
        }
    }

    template<
        typename... argument_types
    >
    constexpr auto simplify_expression(
        divide_op<argument_types...> op
    ) {
        static_assert((is_symbolic_type<argument_types> && ...), "All arguments must be symbolic types.");
        static_cast<void>(op);
        if constexpr (sizeof...(argument_types) == 0) {
            return zero{};
        }
        else if constexpr (sizeof...(argument_types) == 1) {
            return argument_first<argument_types...>{};
        }
        else {
            return operation_from_argument_pack(
                divide_handler{},
                simplifier_stages<argument_types...>(
                    []() {
                        return simplify_argument<argument_types...>(
                            [](auto argument){
                                return argument_pack<decltype(simplify_expression(argument))>{};
                            }
                        );
                    },
                    [](){
                        return simplify_argument_pair<argument_types...>(
                            [](auto lhs, auto rhs) {
                                static_assert(is_same_type<zero, decltype(rhs)> == false, "Division by zero is undefined.");
                                if constexpr (is_same_type<decltype(lhs), zero>) {
                                    return argument_pack<zero>{};
                                }
                                else if constexpr (is_same_type<decltype(lhs), decltype(rhs)>) {
                                    return argument_pack<one>{};
                                }
                                else if constexpr (is_constant_type<decltype(lhs)> && is_constant_type<decltype(rhs)>) {
                                    return argument_pack<constant<decltype(typename decltype(lhs)::type{} / typename decltype(rhs)::type{})>>{};
                                }
                                else {
                                    return argument_pack<decltype(simplify_expression(lhs)), decltype(simplify_expression(rhs))>{};
                                }
                            }
                        );
                    }
                )
            );
        }
    }

    ///////////////////////////////////////////////////////////////////////////

    #define GTL_DEFINE_DEFAULT_UNARY_SIMPLIFIER(OPERATION)                                                                      \
        template<                                                                                                               \
            typename argument_type                                                                                              \
        >                                                                                                                       \
        constexpr auto simplify_expression(                                                                                     \
            OPERATION ## _op<argument_type> op                                                                                  \
        ) {                                                                                                                     \
            static_assert(is_symbolic_type<argument_type>, "All arguments must be symbolic types.");                            \
            static_cast<void>(op);                                                                                              \
            if constexpr (is_constant_type<argument_type>) {                                                                    \
                /*TODO: Solve for best combined type.*/                                                                         \
                return constant<integer<OPERATION ## _handler::template apply<int>(argument_type::template solve<int>())>>{};   \
            }                                                                                                                   \
            else {                                                                                                              \
                return OPERATION ## _op<decltype(simplify_expression(argument_type{}))>{};                                      \
            }                                                                                                                   \
        }                                                                                                                       \

    GTL_DEFINE_DEFAULT_UNARY_SIMPLIFIER(sign)
    GTL_DEFINE_DEFAULT_UNARY_SIMPLIFIER(abs)
    //TODO: Need constexpr version: GTL_DEFINE_DEFAULT_UNARY_SIMPLIFIER(ceil)
    //TODO: Need constexpr version: GTL_DEFINE_DEFAULT_UNARY_SIMPLIFIER(floor)
    //TODO: Need constexpr version: GTL_DEFINE_DEFAULT_UNARY_SIMPLIFIER(exp)
    //TODO: Need constexpr version: GTL_DEFINE_DEFAULT_UNARY_SIMPLIFIER(log)
    //TODO: Need constexpr version: GTL_DEFINE_DEFAULT_UNARY_SIMPLIFIER(exp2)
    //TODO: Need constexpr version: GTL_DEFINE_DEFAULT_UNARY_SIMPLIFIER(log2)
    //TODO: Need constexpr version: GTL_DEFINE_DEFAULT_UNARY_SIMPLIFIER(sin)
    //TODO: Need constexpr version: GTL_DEFINE_DEFAULT_UNARY_SIMPLIFIER(asin)
    //TODO: Need constexpr version: GTL_DEFINE_DEFAULT_UNARY_SIMPLIFIER(cos)
    //TODO: Need constexpr version: GTL_DEFINE_DEFAULT_UNARY_SIMPLIFIER(acos)
    //TODO: Need constexpr version: GTL_DEFINE_DEFAULT_UNARY_SIMPLIFIER(tan)
    //TODO: Need constexpr version: GTL_DEFINE_DEFAULT_UNARY_SIMPLIFIER(atan)
    //TODO: Need constexpr version: GTL_DEFINE_DEFAULT_UNARY_SIMPLIFIER(sinh)
    //TODO: Need constexpr version: GTL_DEFINE_DEFAULT_UNARY_SIMPLIFIER(asinh)
    //TODO: Need constexpr version: GTL_DEFINE_DEFAULT_UNARY_SIMPLIFIER(cosh)
    //TODO: Need constexpr version: GTL_DEFINE_DEFAULT_UNARY_SIMPLIFIER(acosh)
    //TODO: Need constexpr version: GTL_DEFINE_DEFAULT_UNARY_SIMPLIFIER(tanh)
    //TODO: Need constexpr version: GTL_DEFINE_DEFAULT_UNARY_SIMPLIFIER(atanh)
    //TODO: Need constexpr version: GTL_DEFINE_DEFAULT_UNARY_SIMPLIFIER(sqrt)
    //TODO: Need constexpr version: GTL_DEFINE_DEFAULT_UNARY_SIMPLIFIER(cbrt)

    template<
        typename... argument_types
    >
    constexpr auto simplify_expression(
        min_op<argument_types...> op
    ) {
        static_assert((is_symbolic_type<argument_types> && ...), "All arguments must be symbolic types.");
        static_cast<void>(op);
        static_assert(sizeof...(argument_types) > 0);
        if constexpr (sizeof...(argument_types) == 1) {
            return argument_first<argument_types...>{};
        }
        else {
            return operation_from_argument_pack(
                min_handler{},
                simplifier_stages<argument_types...>(
                    []() {
                        return simplify_argument<argument_types...>(
                            [](auto argument){
                                return argument_pack<decltype(simplify_expression(argument))>{};
                            }
                        );
                    },
                    [](){
                        return simplify_argument_pair<argument_types...>(
                            [](auto lhs, auto rhs) {
                                if constexpr (is_same_type<decltype(lhs), decltype(rhs)>) {
                                    return argument_pack<decltype(lhs)>{};
                                }
                                else if constexpr (is_constant_type<decltype(lhs)> && is_constant_type<decltype(rhs)>) {
                                    return argument_pack<constant<decltype(min(typename decltype(lhs)::type{}, typename decltype(rhs)::type{}))>>{};
                                }
                                else {
                                    return argument_pack<decltype(simplify_expression(lhs)), decltype(simplify_expression(rhs))>{};
                                }
                            }
                        );
                    }
                )
            );
        }
    }

    template<
        typename... argument_types
    >
    constexpr auto simplify_expression(
        max_op<argument_types...> op
    ) {
        static_assert((is_symbolic_type<argument_types> && ...), "All arguments must be symbolic types.");
        static_cast<void>(op);
        static_assert(sizeof...(argument_types) > 0);
        if constexpr (sizeof...(argument_types) == 1) {
            return argument_first<argument_types...>{};
        }
        else {
            return operation_from_argument_pack(
                max_handler{},
                simplifier_stages<argument_types...>(
                    []() {
                        return simplify_argument<argument_types...>(
                            [](auto argument){
                                return argument_pack<decltype(simplify_expression(argument))>{};
                            }
                        );
                    },
                    [](){
                        return simplify_argument_pair<argument_types...>(
                            [](auto lhs, auto rhs) {
                                if constexpr (is_same_type<decltype(lhs), decltype(rhs)>) {
                                    return argument_pack<decltype(lhs)>{};
                                }
                                else if constexpr (is_constant_type<decltype(lhs)> && is_constant_type<decltype(rhs)>) {
                                    return argument_pack<constant<decltype(max(typename decltype(lhs)::type{}, typename decltype(rhs)::type{}))>>{};
                                }
                                else {
                                    return argument_pack<decltype(simplify_expression(lhs)), decltype(simplify_expression(rhs))>{};
                                }
                            }
                        );
                    }
                )
            );
        }
    }

    template<
        typename lhs_type,
        typename rhs_type
    >
    constexpr auto simplify_expression(
        hypot_op<lhs_type, rhs_type> op
    ) {
        static_assert((is_symbolic_type<lhs_type> && is_symbolic_type<rhs_type>), "All arguments must be symbolic types.");
        static_cast<void>(op);
        return operation_from_argument_pack(
            hypot_handler{},
            simplifier_stages<lhs_type, rhs_type>(
                []() {
                    return simplify_argument<lhs_type, rhs_type>(
                        [](auto argument){
                            return argument_pack<decltype(simplify_expression(argument))>{};
                        }
                    );
                }/*TODO CONSTANT hypot(),
                [](){
                    return simplify_argument_pair<lhs_type, rhs_type>(
                        [](auto lhs, auto rhs) {
                            if constexpr (is_constant_type<decltype(lhs)> && is_constant_type<decltype(rhs)>) {
                                return argument_pack<constant<decltype(hypot(typename decltype(lhs)::type{}, typename decltype(rhs)::type{}))>>{};
                            }
                            else {
                                return argument_pack<decltype(simplify_expression(lhs)), decltype(simplify_expression(rhs))>{};
                            }
                        }
                    );
                }*/
            )
        );
    }

    template<
        typename lhs_type,
        typename rhs_type
    >
    constexpr auto simplify_expression(
        atan2_op<lhs_type, rhs_type> op
    ) {
        static_assert((is_symbolic_type<lhs_type> && is_symbolic_type<rhs_type>), "All arguments must be symbolic types.");
        static_cast<void>(op);
        return operation_from_argument_pack(
            atan2_handler{},
            simplifier_stages<lhs_type, rhs_type>(
                []() {
                    return simplify_argument<lhs_type, rhs_type>(
                        [](auto argument){
                            return argument_pack<decltype(simplify_expression(argument))>{};
                        }
                    );
                }/*TODO CONSTANT atan2(),
                [](){
                    return simplify_argument_pair<lhs_type, rhs_type>(
                        [](auto lhs, auto rhs) {
                            if constexpr (is_const_type<decltype(lhs)> && is_const_type<decltype(rhs)>) {
                                return argument_pack<constant<decltype(atan2(typename decltype(lhs)::type{}, typename decltype(rhs)::type{}))>>{};
                            }
                            else {
                                return argument_pack<decltype(simplify_expression(lhs)), decltype(simplify_expression(rhs))>{};
                            }
                        }
                    );
                }*/
            )
        );
    }

    template<
        typename lhs_type,
        typename rhs_type
    >
    constexpr auto simplify_expression(
        pow_op<lhs_type, rhs_type> op
    ) {
        static_assert((is_symbolic_type<lhs_type> && is_symbolic_type<rhs_type>), "All arguments must be symbolic types.");
        static_cast<void>(op);
        static_assert(((is_same_type<lhs_type, zero> != true) || is_same_type<rhs_type, zero> != true), "Zero to power zero is undefined.");
        if constexpr(is_same_type<lhs_type, zero>) {
            return zero{};
        } else if constexpr(is_same_type<lhs_type, one>) {
            return one{};
        } else if constexpr(is_same_type<rhs_type, zero>) {
            return one{};
        } else if constexpr(is_same_type<rhs_type, one>) {
            return lhs_type{};
        /*
        TODO CONSTANT pow()
        } else if constexpr(is_const_type<lhs_type> && is_const_type<rhs_type>) {
            return argument_pack<constant<decltype(pow(typename decltype(lhs)::type{}, typename decltype(rhs)::type{}))>>{};
        */
        } else if constexpr(is_same_type<lhs_type, multiply_op<>>){
            return operation_from_argument_pack(
                multiply_handler{},
                simplifier_stages<lhs_type, rhs_type>(
                    []() {
                        return simplify_argument<lhs_type, rhs_type>(
                            [](auto argument){
                                return argument_pack<pow_op<decltype(simplify_expression(argument)), rhs_type>>{};
                            }
                        );
                    }
                )
            );
        } else {
            return pow_op<decltype(simplify_expression(lhs_type{})), decltype(simplify_expression(rhs_type{}))>{};
        }
    }

    ///////////////////////////////////////////////////////////////////////////

    // Catch all simplifier.
    template<
        typename operation_type,
        typename... argument_types
    >
    constexpr auto simplify_expression(
        operation<operation_type, argument_types...> op
    ) {
        static_assert((is_symbolic_type<argument_types> && ...), "All arguments must be symbolic types.");
        static_cast<void>(op);
        return operation<operation_type, decltype(simplify_expression(argument_types{}))...>{};
    }

    ///////////////////////////////////////////////////////////////////////////

    template <
        typename argument_type
    >
    constexpr auto simplify_fully(
        argument_type argument
    ) {
        static_assert(is_symbolic_type<argument_type>, "All arguments must be symbolic types.");
        static_cast<void>(argument);
        auto simplified = simplify_expression(argument_type{});
        if constexpr(is_same_type<argument_type, decltype(simplified)>) {
            return simplified;
        } else {
            return simplify_fully(simplified);
        }
    }

    template <
        typename argument_type
    >
    constexpr auto simplify_fully_with_history(
        argument_pack<argument_type> pack
    ) {
        static_assert(is_symbolic_type<argument_type>, "All arguments must be symbolic types.");
        static_cast<void>(pack);
        auto simplified = simplify_expression(argument_type{});
        if constexpr(is_same_type<argument_type, decltype(simplified)>) {
            return argument_pack<decltype(simplified)>{};
        } else {
            auto simplified_further = simplify_fully_with_history(argument_pack<decltype(simplified)>{});
            return merge_argument_packs(pack, simplified_further);
        }
    }

    template <
        typename argument_type
    >
    constexpr auto simplify_fully_with_history(
        argument_type argument
    ) {
        static_assert(is_symbolic_type<argument_type>, "All arguments must be symbolic types.");
        static_cast<void>(argument);
        return simplify_fully_with_history(argument_pack<argument_type>{});
    }

    ///////////////////////////////////////////////////////////////////////////
    /// Differentiation.
    ///////////////////////////////////////////////////////////////////////////

    template <
        unsigned long long int derivative_index,
        unsigned long long int parameter_index
    >
    constexpr auto derive_expression(
        parameter<parameter_index>
    ) {
        if constexpr (parameter_index == derivative_index) {
            return one{};
        }
        else {
            return zero{};
        }
    }

    template <
        unsigned long long int derivative_index,
        unsigned long long int variable_index
    >
    constexpr auto derive_expression(
        variable<variable_index>
    ) {
        return zero{};
    }

    template <
        unsigned long long int derivative_index,
        typename constant_type
    >
    constexpr auto derive_expression(
        constant<constant_type>
    ) {
        return zero{};
    }

    ///////////////////////////////////////////////////////////////////////////

    template <
        unsigned long long int derivative_index,
        typename argument_type
    >
    constexpr auto derive_expression(
        plus_op<argument_type> op
    ) {
        static_assert(is_symbolic_type<argument_type>, "All arguments must be symbolic types.");
        static_cast<void>(op);
        return derive_expression<derivative_index>(argument_type{});
    }

    template <
        unsigned long long int derivative_index,
        typename argument_type
    >
    constexpr auto derive_expression(
        minus_op<argument_type> op
    ) {
        static_assert(is_symbolic_type<argument_type>, "All arguments must be symbolic types.");
        static_cast<void>(op);
        return minus_op<decltype(derive_expression<derivative_index>(argument_type{}))>{};
    }

    template <
        unsigned long long int derivative_index,
        typename... argument_types
    >
    constexpr auto derive_expression(
        add_op<argument_types...> op
    ) {
        static_assert((is_symbolic_type<argument_types> && ...), "All arguments must be symbolic types.");
        static_cast<void>(op);
        return add_op<decltype(derive_expression<derivative_index>(argument_types{}))...>{};
    }

    template <
        unsigned long long int derivative_index,
        typename... argument_types
    >
    constexpr auto derive_expression(
        subtract_op<argument_types...> op
    ) {
        static_assert((is_symbolic_type<argument_types> && ...), "All arguments must be symbolic types.");
        static_cast<void>(op);
        return subtract_op<decltype(derive_expression<derivative_index>(argument_types{}))...>{};
    }

    template <
        unsigned long long int derivative_index,
        typename argument_type,
        typename... argument_types
    >
    constexpr auto derive_expression(
        multiply_op<argument_type, argument_types...> op
    ) {
        static_assert(is_symbolic_type<argument_type> && (is_symbolic_type<argument_types> && ...), "All arguments must be symbolic types.");
        static_cast<void>(op);
        using d_lhs_times_rhs = multiply_op<decltype(derive_expression<derivative_index>(argument_type{})), multiply_op<argument_types...>>;
        using lhs_times_d_rhs = multiply_op<argument_type, decltype(derive_expression<derivative_index>(simplify_fully(multiply_op<argument_types...>{})))>;
        return add_op<d_lhs_times_rhs, lhs_times_d_rhs>{};
    }

    template <
        unsigned long long int derivative_index,
        typename lhs_type,
        typename rhs_type
    >
    constexpr auto derive_expression(
        divide_op<lhs_type, rhs_type> op
    ) {
        static_assert(is_symbolic_type<lhs_type> && is_symbolic_type<rhs_type>, "All arguments must be symbolic types.");
        static_cast<void>(op);
        using d_lhs = decltype(derive_expression<derivative_index>(lhs_type{}));
        using d_rhs = decltype(derive_expression<derivative_index>(rhs_type{}));
        using d_lhs_times_rhs = multiply_op<d_lhs, rhs_type>;
        using lhs_times_d_rhs = multiply_op<lhs_type, d_rhs>;
        using sub_dlxr_lxdr = subtract_op<d_lhs_times_rhs, lhs_times_d_rhs>;
        using rhs_squared = pow_op<rhs_type, two>;
        return divide_op<sub_dlxr_lxdr, rhs_squared>{};
    }

    ///////////////////////////////////////////////////////////////////////////

    template <
        unsigned long long int derivative_index,
        typename argument_type
    >
    constexpr auto derive_expression(
        sign_op<argument_type> op
    ) {
        static_assert(is_symbolic_type<argument_type>, "All arguments must be symbolic types.");
        // Sign has a derivative of zero when the number is not zero, otherwise it is indeterminate.
        // Ceres says this operation will result in a zero derivative which provides no information to the solver.
        static_cast<void>(op);
        return zero{};
    }

    template <
        unsigned long long int derivative_index,
        typename argument_type
    >
    constexpr auto derive_expression(
        abs_op<argument_type> op
    ) {
        static_assert(is_symbolic_type<argument_type>, "All arguments must be symbolic types.");
        static_cast<void>(op);
        using d_arg = decltype(derive_expression<derivative_index>(argument_type{}));
        return multiply_op<sign_op<argument_type>, d_arg>{};
    }

    template <
        unsigned long long int derivative_index,
        typename argument_type
    >
    constexpr auto derive_expression(
        ceil_op<argument_type> op
    ) {
        static_assert(is_symbolic_type<argument_type>, "All arguments must be symbolic types.");
        // Ceil has a derivative of zero when the number is not an integer, otherwise it is indeterminate.
        // Ceres says this operation will result in a zero derivative which provides no information to the solver.
        static_cast<void>(op);
        return zero{};
    }

    template <
        unsigned long long int derivative_index,
        typename argument_type
    >
    constexpr auto derive_expression(
        floor_op<argument_type> op
    ) {
        static_assert(is_symbolic_type<argument_type>, "All arguments must be symbolic types.");
        // Floor has a derivative of zero when the number is not an integer, otherwise it is indeterminate.
        // Ceres says this operation will result in a zero derivative which provides no information to the solver.
        static_cast<void>(op);
        return zero{};
    }

    ///////////////////////////////////////////////////////////////////////////

    template <
        unsigned long long int derivative_index,
        typename argument_type
    >
    constexpr auto derive_expression(
        exp_op<argument_type> op
    ) {
        static_assert(is_symbolic_type<argument_type>, "All arguments must be symbolic types.");
        static_cast<void>(op);
        using d_arg = decltype(derive_expression<derivative_index>(argument_type{}));
        return multiply_op<d_arg, exp_op<argument_type>>{};
    }

    template <
        unsigned long long int derivative_index,
        typename argument_type
    >
    constexpr auto derive_expression(
        log_op<argument_type> op
    ) {
        static_assert(is_symbolic_type<argument_type>, "All arguments must be symbolic types.");
        static_cast<void>(op);
        using d_arg = decltype(derive_expression<derivative_index>(argument_type{}));
        return divide_op<d_arg, argument_type>{};
    }

    template <
        unsigned long long int derivative_index,
        typename argument_type
    >
    constexpr auto derive_expression(
        exp2_op<argument_type> op
    ) {
        static_assert(is_symbolic_type<argument_type>, "All arguments must be symbolic types.");
        static_cast<void>(op);
        using d_arg = decltype(derive_expression<derivative_index>(argument_type{}));
        return multiply_op<log_op<two>, exp2_op<argument_type>, d_arg>{};
    }

    template <
        unsigned long long int derivative_index,
        typename argument_type
    >
    constexpr auto derive_expression(
        log2_op<argument_type> op
    ) {
        static_assert(is_symbolic_type<argument_type>, "All arguments must be symbolic types.");
        static_cast<void>(op);
        using d_arg = decltype(derive_expression<derivative_index>(argument_type{}));
        return divide_op<d_arg, multiply_op<log_op<two>, argument_type>>{};
    }

    ///////////////////////////////////////////////////////////////////////////

    template <
        unsigned long long int derivative_index,
        typename argument_type
    >
    constexpr auto derive_expression(
        sin_op<argument_type> op
    ) {
        static_assert(is_symbolic_type<argument_type>, "All arguments must be symbolic types.");
        static_cast<void>(op);
        using d_arg = decltype(derive_expression<derivative_index>(argument_type{}));
        return multiply_op<cos_op<argument_type>, d_arg>{};
    }

    template <
        unsigned long long int derivative_index,
        typename argument_type
    >
    constexpr auto derive_expression(
        asin_op<argument_type> op
    ) {
        static_assert(is_symbolic_type<argument_type>, "All arguments must be symbolic types.");
        static_cast<void>(op);
        using d_arg = decltype(derive_expression<derivative_index>(argument_type{}));
        return divide_op<d_arg, sqrt_op<subtract_op<one, pow_op<argument_type, two>>>>{};
    }

    template <
        unsigned long long int derivative_index,
        typename argument_type
    >
    constexpr auto derive_expression(
        cos_op<argument_type> op
    ) {
        static_assert(is_symbolic_type<argument_type>, "All arguments must be symbolic types.");
        static_cast<void>(op);
        using d_arg = decltype(derive_expression<derivative_index>(argument_type{}));
        return multiply_op<minus_op<sin_op<argument_type>>, d_arg>{};
    }

    template <
        unsigned long long int derivative_index,
        typename argument_type
    >
    constexpr auto derive_expression(
        acos_op<argument_type> op
    ) {
        static_assert(is_symbolic_type<argument_type>, "All arguments must be symbolic types.");
        static_cast<void>(op);
        using d_arg = decltype(derive_expression<derivative_index>(argument_type{}));
        return divide_op<multiply_op<minus_one, d_arg>, sqrt_op<subtract_op<one, pow_op<argument_type, two>>>>{};
    }

    template <
        unsigned long long int derivative_index,
        typename argument_type
    >
    constexpr auto derive_expression(
        tan_op<argument_type> op
    ) {
        static_assert(is_symbolic_type<argument_type>, "All arguments must be symbolic types.");
        static_cast<void>(op);
        using d_arg = decltype(derive_expression<derivative_index>(argument_type{}));
        return divide_op<d_arg, pow_op<cos_op<argument_type>, two>>{};
    }

    template <
        unsigned long long int derivative_index,
        typename argument_type
    >
    constexpr auto derive_expression(
        atan_op<argument_type> op
    ) {
        static_assert(is_symbolic_type<argument_type>, "All arguments must be symbolic types.");
        static_cast<void>(op);
        using d_arg = decltype(derive_expression<derivative_index>(argument_type{}));
        return divide_op<d_arg, add_op<one, pow_op<argument_type, two>>>{};
    }

    ///////////////////////////////////////////////////////////////////////////

    template <
        unsigned long long int derivative_index,
        typename argument_type
    >
    constexpr auto derive_expression(
        sinh_op<argument_type> op
    ) {
        static_assert(is_symbolic_type<argument_type>, "All arguments must be symbolic types.");
        static_cast<void>(op);
        using d_arg = decltype(derive_expression<derivative_index>(argument_type{}));
        return multiply_op<cosh_op<argument_type>, d_arg>{};
    }

    template <
        unsigned long long int derivative_index,
        typename argument_type
    >
    constexpr auto derive_expression(
        asinh_op<argument_type> op
    ) {
        static_assert(is_symbolic_type<argument_type>, "All arguments must be symbolic types.");
        static_cast<void>(op);
        using d_arg = decltype(derive_expression<derivative_index>(argument_type{}));
        return divide_op<d_arg, sqrt_op<add_op<pow_op<argument_type, two>, one>>>{};
    }

    template <
        unsigned long long int derivative_index,
        typename argument_type
    >
    constexpr auto derive_expression(
        cosh_op<argument_type> op
    ) {
        static_assert(is_symbolic_type<argument_type>, "All arguments must be symbolic types.");
        static_cast<void>(op);
        using d_arg = decltype(derive_expression<derivative_index>(argument_type{}));
        return multiply_op<sinh_op<argument_type>, d_arg>{};
    }

    template <
        unsigned long long int derivative_index,
        typename argument_type
    >
    constexpr auto derive_expression(
        acosh_op<argument_type> op
    ) {
        static_assert(is_symbolic_type<argument_type>, "All arguments must be symbolic types.");
        static_cast<void>(op);
        using d_arg = decltype(derive_expression<derivative_index>(argument_type{}));
        return divide_op<d_arg, sqrt_op<subtract_op<pow_op<argument_type, two>, one>>>{};
    }

    template <
        unsigned long long int derivative_index,
        typename argument_type
    >
    constexpr auto derive_expression(
        tanh_op<argument_type> op
    ) {
        static_assert(is_symbolic_type<argument_type>, "All arguments must be symbolic types.");
        static_cast<void>(op);
        using d_arg = decltype(derive_expression<derivative_index>(argument_type{}));
        return divide_op<d_arg, pow_op<cosh_op<argument_type>, two>>{};
    }

    template <
        unsigned long long int derivative_index,
        typename argument_type
    >
    constexpr auto derive_expression(
        atanh_op<argument_type> op
    ) {
        static_assert(is_symbolic_type<argument_type>, "All arguments must be symbolic types.");
        static_cast<void>(op);
        using d_arg = decltype(derive_expression<derivative_index>(argument_type{}));
        return divide_op<d_arg, subtract_op<one, pow_op<argument_type, two>>>{};
    }

    ///////////////////////////////////////////////////////////////////////////

    template <
        unsigned long long int derivative_index,
        typename argument_type
    >
    constexpr auto derive_expression(
        sqrt_op<argument_type> op
    ) {
        static_assert(is_symbolic_type<argument_type>, "All arguments must be symbolic types.");
        static_cast<void>(op);
        using d_arg = decltype(derive_expression<derivative_index>(argument_type{}));
        return divide_op<d_arg, multiply_op<two, sqrt_op<argument_type>>>{};
    }


    template <
        unsigned long long int derivative_index,
        typename argument_type
    >
    constexpr auto derive_expression(
        cbrt_op<argument_type> op
    ) {
        static_assert(is_symbolic_type<argument_type>, "All arguments must be symbolic types.");
        static_cast<void>(op);
        using d_arg = decltype(derive_expression<derivative_index>(argument_type{}));
        return divide_op<d_arg, multiply_op<three, pow_op<cbrt_op<argument_type>, two>>>{};
    }

    ///////////////////////////////////////////////////////////////////////////

    template <
        unsigned long long int derivative_index,
        typename lhs_type,
        typename rhs_type
    >
    constexpr auto derive_expression(
        min_op<lhs_type, rhs_type> op
    ) {
        static_assert(is_symbolic_type<lhs_type> && is_symbolic_type<rhs_type>, "All arguments must be symbolic types.");
        static_cast<void>(op);
        using d_lhs = decltype(derive_expression<derivative_index>(lhs_type{}));
        using d_rhs = decltype(derive_expression<derivative_index>(rhs_type{}));
        return divide_op<add_op<multiply_op<sign_op<subtract_op<lhs_type, rhs_type>>, subtract_op<d_rhs, d_lhs>>, d_lhs, d_rhs>, two>{};
    }

    template <
        unsigned long long int derivative_index,
        typename lhs_type,
        typename rhs_type
    >
    constexpr auto derive_expression(
        max_op<lhs_type, rhs_type> op
    ) {
        static_assert(is_symbolic_type<lhs_type> && is_symbolic_type<rhs_type>, "All arguments must be symbolic types.");
        static_cast<void>(op);
        using d_lhs = decltype(derive_expression<derivative_index>(lhs_type{}));
        using d_rhs = decltype(derive_expression<derivative_index>(rhs_type{}));
        return divide_op<add_op<multiply_op<sign_op<subtract_op<lhs_type, rhs_type>>, subtract_op<d_lhs, d_rhs>>, d_lhs, d_rhs>, two>{};
    }

    ///////////////////////////////////////////////////////////////////////////

    template <
        unsigned long long int derivative_index,
        typename lhs_type,
        typename rhs_type
    >
    constexpr auto derive_expression(
        hypot_op<lhs_type, rhs_type> op
    ) {
        static_assert(is_symbolic_type<lhs_type> && is_symbolic_type<rhs_type>, "All arguments must be symbolic types.");
        static_cast<void>(op);
        using d_lhs = decltype(derive_expression<derivative_index>(lhs_type{}));
        using d_rhs = decltype(derive_expression<derivative_index>(rhs_type{}));
        return divide_op<subtract_op<multiply_op<lhs_type, d_lhs>, multiply_op<rhs_type, d_rhs>>, sqrt_op<add_op<pow_op<lhs_type, two>, pow_op<rhs_type, two>>>>{};
    }

    template <
        unsigned long long int derivative_index,
        typename lhs_type,
        typename rhs_type
    >
    constexpr auto derive_expression(
        atan2_op<lhs_type, rhs_type> op
    ) {
        static_assert(is_symbolic_type<lhs_type> && is_symbolic_type<rhs_type>, "All arguments must be symbolic types.");
        static_cast<void>(op);
        using d_lhs = decltype(derive_expression<derivative_index>(lhs_type{}));
        using d_rhs = decltype(derive_expression<derivative_index>(rhs_type{}));
        return divide_op<subtract_op<multiply_op<d_lhs, rhs_type>, multiply_op<lhs_type, d_rhs>>, add_op<pow_op<lhs_type, two>, pow_op<rhs_type, two>>>{};
    }

    ///////////////////////////////////////////////////////////////////////////

    template <
        unsigned long long int derivative_index,
        typename argument_type,
        typename constant_type
    >
    constexpr auto derive_expression(
        pow_op<argument_type, constant<constant_type>> op
    ) {
        static_assert(is_symbolic_type<argument_type>, "All arguments must be symbolic types.");
        static_cast<void>(op);
        using d_lhs = decltype(derive_expression<derivative_index>(argument_type{}));
        return multiply_op<multiply_op<constant<constant_type>, pow_op<argument_type, constant<decltype(constant_type{} - integer<1>{})>>>, d_lhs>{};
    }

    template <
        unsigned long long int derivative_index,
        typename lhs_type,
        typename rhs_type
    >
    constexpr auto derive_expression(
        pow_op<lhs_type, rhs_type> op
    ) {
        static_assert(is_symbolic_type<lhs_type> && is_symbolic_type<rhs_type>, "All arguments must be symbolic types.");
        static_cast<void>(op);
        using d_lhs = decltype(derive_expression<derivative_index>(lhs_type{}));
        using d_rhs = decltype(derive_expression<derivative_index>(rhs_type{}));
        return multiply_op<pow_op<lhs_type, rhs_type>, add_op<multiply_op<d_rhs, log_op<lhs_type>>, divide_op<multiply_op<rhs_type, d_lhs>, lhs_type>>>{};
    }

    ///////////////////////////////////////////////////////////////////////////

    template<
        unsigned long long int derivative_index,
        unsigned long long int depth = 0,
        typename argument_type
    >
    constexpr auto derive_to_depth(argument_type argument) {
        static_assert(is_symbolic_type<argument_type>, "All arguments must be symbolic types.");
        auto derived = simplify_fully(derive_expression<derivative_index>(simplify_fully(argument)));
        if constexpr(depth == 0) {
            return derived;
        } else {
            return derive_to_depth<derivative_index, depth - 1>(derived);
        }
    }

    template<
        unsigned long long int derivative_index,
        unsigned long long int depth = 0,
        typename argument_type
    >
    constexpr auto derive_to_depth_with_history(argument_pack<argument_type> pack) {
        static_assert(is_symbolic_type<argument_type>, "All arguments must be symbolic types.");
        static_cast<void>(pack);
        auto derived = simplify_fully(derive_expression<derivative_index>(simplify_fully(argument_type{})));
        if constexpr(depth == 0) {
            return argument_pack<decltype(derived)>{};
        } else {
            auto derived_further = derive_to_depth_with_history<derivative_index, depth - 1>(argument_pack<decltype(derived)>{});
            return merge_argument_packs(argument_pack<decltype(derived)>{}, derived_further);
        }
    }

    template<
        unsigned long long int derivative_index,
        unsigned long long int depth = 0,
        typename argument_type
    >
    constexpr auto derive_to_depth_with_history(argument_type argument) {
        static_assert(is_symbolic_type<argument_type>, "All arguments must be symbolic types.");
        static_cast<void>(argument);
        return derive_to_depth_with_history<derivative_index, depth>(argument_pack<argument_type>{});
    }

    ///////////////////////////////////////////////////////////////////////////
    /// Integration.
    ///////////////////////////////////////////////////////////////////////////

    //...

    ///////////////////////////////////////////////////////////////////////////
    /// Matrix Operations.
    ///////////////////////////////////////////////////////////////////////////

    template <
        unsigned long long int... indexes
    >
    class integer_sequence {
    public:
        using sequence_type = integer_sequence;
    };

    template <
        typename lhs_sequence,
        typename rhs_sequence
    >
    class merge_sequences;

    template <
        unsigned long long int... lhs_indexes,
        unsigned long long int... rhs_indexes
    >
    class merge_sequences<integer_sequence<lhs_indexes...>, integer_sequence<rhs_indexes...>>
        : public integer_sequence<lhs_indexes..., (sizeof...(lhs_indexes) + rhs_indexes)...> {
    };

    template <
        unsigned long long int length
    >
    class make_integer_sequence final
        : public merge_sequences<typename make_integer_sequence<length / 2>::sequence_type, typename make_integer_sequence<length - length / 2>::sequence_type> {
    };

    template <
    >
    class make_integer_sequence<0> final
        : public integer_sequence<> {
    };

    template<
    >
    class make_integer_sequence<1> final
        : public integer_sequence<0> {
    };

    template <
        unsigned long long int index,
        typename... argument_types
    >
    class element_type;

    template <
        unsigned long long int index,
        typename argument_type,
        typename... argument_types
    >
    class element_type<index, argument_type, argument_types...> final {
    public:
        using type = typename element_type<index - 1, argument_types...>::type;
    };

    template <
        typename argument_type,
        typename... argument_types
    >
    class element_type<0, argument_type, argument_types...> final {
    public:
        using type = argument_type;
    };

    template <
        unsigned long long int index,
        typename... argument_types
    >
    using element = typename element_type<index, argument_types...>::type;



    template <
        unsigned long long int rows,
        unsigned long long int columns,
        typename... argument_types
    >
    class matrix final {
        static_assert(rows > 0, "");
        static_assert(columns > 0, "");
        static_assert(sizeof...(argument_types) == rows * columns, "");
    };

    template <
        typename argument_type
    >
    class matrix<1, 1, argument_type> final {
    public:
        using type = argument_type;
    };

    template <
        unsigned long long int index_row,
        unsigned long long int rows,
        unsigned long long int columns,
        unsigned long long int... indexes,
        typename... argument_types
    >
    constexpr inline auto get_row(matrix<rows, columns, argument_types...> m, integer_sequence<indexes...> index_sequence) {
        static_assert(index_row < rows, "");
        static_assert(sizeof...(indexes) == columns, "");
        static_cast<void>(m);
        static_cast<void>(index_sequence);
        return matrix<1, columns, element<index_row * columns + indexes, argument_types...>...>{};
    }

    template <
        unsigned long long int index_row,
        unsigned long long int rows,
        unsigned long long int columns,
        typename... argument_types
    >
    constexpr inline auto get_row(matrix<rows, columns, argument_types...> m) {
        static_assert(index_row < rows, "");
        return get_row<index_row>(m, make_integer_sequence<columns>{});
    }

    template <
        unsigned long long int index_column,
        unsigned long long int rows,
        unsigned long long int columns,
        typename... argument_types,
        unsigned long long int... indexes
    >
    constexpr inline auto get_column(matrix<rows, columns, argument_types...> m, integer_sequence<indexes...> index_sequence) {
        static_assert(index_column < columns, "");
        static_assert(sizeof...(indexes) == rows, "");
        static_cast<void>(m);
        static_cast<void>(index_sequence);
        return matrix<rows, 1, element<index_column + columns * indexes, argument_types...>...>{};
    }

    template <
        unsigned long long int index_column,
        unsigned long long int rows,
        unsigned long long int columns,
        typename... argument_types
    >
    constexpr inline auto get_column(matrix<rows, columns, argument_types...> m) {
        static_assert(index_column < columns, "");
        return get_column<index_column>(m, make_integer_sequence<rows>{});
    }

    template <
        unsigned long long int index_row,
        unsigned long long int index_column,
        unsigned long long int rows,
        unsigned long long int columns,
        typename... argument_types
    >
    constexpr inline auto get_cell(matrix<rows, columns, argument_types...> m) {
        static_assert(index_row < rows, "");
        static_assert(index_column < columns, "");
        return typename decltype(get_column<index_column>(get_row<index_row>(m)))::type{};
    }

    template <
        unsigned long long int rows,
        unsigned long long int columns,
        typename... lhs_types,
        typename rhs_type
    >
    constexpr inline auto operator+(
        matrix<rows, columns, lhs_types...> lhs,
        rhs_type rhs
    ) {
        static_cast<void>(lhs);
        static_cast<void>(rhs);
        return matrix<rows, columns, decltype(lhs_types{} + rhs_type{})...>{};
    }

    template <
        unsigned long long int rows,
        unsigned long long int columns,
        typename lhs_type,
        typename... rhs_types
    >
    constexpr inline auto operator+(
        lhs_type lhs,
        matrix<rows, columns, rhs_types...> rhs
    ) {
        static_cast<void>(lhs);
        static_cast<void>(rhs);
        return matrix<rows, columns, decltype(lhs_type{} + rhs_types{})...>{};
    }

    template <
        unsigned long long int rows,
        unsigned long long int columns,
        typename... lhs_types,
        typename... rhs_types
    >
    constexpr inline auto operator+(
        matrix<rows, columns, lhs_types...> lhs,
        matrix<rows, columns, rhs_types...> rhs
    ) {
        static_cast<void>(lhs);
        static_cast<void>(rhs);
        return matrix<rows, columns, decltype(lhs_types{} + rhs_types{})...>{};
    }

    template <
        unsigned long long int rows,
        unsigned long long int columns,
        typename... lhs_types,
        typename rhs_type
    >
    constexpr inline auto operator-(
        matrix<rows, columns, lhs_types...> lhs,
        rhs_type rhs
    ) {
        static_cast<void>(lhs);
        static_cast<void>(rhs);
        return matrix<rows, columns, decltype(lhs_types{} - rhs_type{})...>{};
    }

    template <
        unsigned long long int rows,
        unsigned long long int columns,
        typename lhs_type,
        typename... rhs_types
    >
    constexpr inline auto operator-(
        lhs_type lhs,
        matrix<rows, columns, rhs_types...> rhs
    ) {
        static_cast<void>(lhs);
        static_cast<void>(rhs);
        return matrix<rows, columns, decltype(lhs_type{} - rhs_types{})...>{};
    }

    template <
        unsigned long long int rows,
        unsigned long long int columns,
        typename... lhs_types,
        typename... rhs_types
    >
    constexpr inline auto operator-(
        matrix<rows, columns, lhs_types...> lhs,
        matrix<rows, columns, rhs_types...> rhs
    ) {
        static_cast<void>(lhs);
        static_cast<void>(rhs);
        return matrix<rows, columns, decltype(lhs_types{} - rhs_types{})...>{};
    }

    template <
        unsigned long long int rows,
        unsigned long long int columns,
        typename... lhs_types,
        typename rhs_type
    >
    constexpr inline auto operator*(
        matrix<rows, columns, lhs_types...> lhs,
        rhs_type rhs
    ) {
        static_cast<void>(lhs);
        static_cast<void>(rhs);
        return matrix<rows, columns, decltype(lhs_types{} * rhs_type{})...>{};
    }

    template <
        unsigned long long int rows,
        unsigned long long int columns,
        typename lhs_type,
        typename... rhs_types
    >
    constexpr inline auto operator*(
        lhs_type lhs,
        matrix<rows, columns, rhs_types...> rhs
    ) {
        static_cast<void>(lhs);
        static_cast<void>(rhs);
        return matrix<rows, columns, decltype(lhs_type{} * rhs_types{})...>{};
    }

    template <
        unsigned long long int size,
        typename... lhs_types,
        typename... rhs_types
    >
    constexpr inline auto operator*(
        matrix<1, size, lhs_types...> lhs,
        matrix<size, 1, rhs_types...> rhs
    ) {
        static_cast<void>(lhs);
        static_cast<void>(rhs);
        return ((lhs_types{} * rhs_types{}) + ...);
    }

    template <
        unsigned long long int lhs_rows,
        unsigned long long int size,
        unsigned long long int rhs_columns,
        typename... lhs_types,
        typename... rhs_types,
        unsigned long long int... indexes
    >
    constexpr inline auto multiply(
        matrix<lhs_rows, size, lhs_types...> lhs,
        matrix<size, rhs_columns, rhs_types...> rhs,
        integer_sequence<indexes...> index_sequence
    ) {
        static_cast<void>(lhs);
        static_cast<void>(rhs);
        static_cast<void>(index_sequence);
        return matrix<lhs_rows, rhs_columns, decltype(get_row<indexes % lhs_rows>(lhs) * get_column<indexes / rhs_columns>(rhs))...>{};
    }

    template <
        unsigned long long int lhs_rows,
        unsigned long long int size,
        unsigned long long int rhs_columns,
        typename... lhs_types,
        typename... rhs_types
    >
    constexpr inline auto operator*(
        matrix<lhs_rows, size, lhs_types...> lhs,
        matrix<size, rhs_columns, rhs_types...> rhs
    ) {
        static_cast<void>(lhs);
        static_cast<void>(rhs);
        return multiply(lhs, rhs, make_integer_sequence<lhs_rows * rhs_columns>{});
    }

    template <
        unsigned long long int rows,
        unsigned long long int columns,
        typename... argument_types,
        unsigned long long int... indexes
    >
    constexpr inline auto transpose(
        matrix<rows, columns, argument_types...> m,
        integer_sequence<indexes...> index_sequence
    ) {
        static_cast<void>(m);
        static_cast<void>(index_sequence);
        return matrix<columns, rows, decltype(get_cell<indexes % rows, indexes / rows>(m))...>{};
        //return matrix<columns, rows, argument_types...>{};
    }

    template <
        unsigned long long int rows,
        unsigned long long int columns,
        typename... argument_types
    >
    constexpr inline auto transpose(
        matrix<rows, columns, argument_types...> m
    ) {
        static_cast<void>(m);
        return transpose(m, make_integer_sequence<rows * columns>{});
    }

    ///////////////////////////////////////////////////////////////////////////
    /// Quaternion Operations.
    ///////////////////////////////////////////////////////////////////////////

    //...

    ///////////////////////////////////////////////////////////////////////////
    /// Lie Algebra Operations.
    ///////////////////////////////////////////////////////////////////////////

    //...

    ///////////////////////////////////////////////////////////////////////////
    /// Geometric Algebra Operations.
    ///////////////////////////////////////////////////////////////////////////

    //...

    ///////////////////////////////////////////////////////////////////////////
    /// MISC.
    ///////////////////////////////////////////////////////////////////////////

#define ALTERNATIVES 0
#if ALTERNATIVES
    template<
        typename parameter_type,
        unsigned long long int parameter_count,
        signed long long int value
    >
    class integer final {
    public:
        constexpr inline const parameter_type& operator()(
            const parameters<parameter_type, parameter_count>& values
        ) const {
            static_cast<void>(values);
            return static_cast<parameter_type>(value);
        }
    };

    template<
        typename parameter_type,
        unsigned long long int parameter_count,
        signed long long int numerator,
        unsigned long long int denominator
    >
    class rational final {
    public:
        constexpr inline const parameter_type& operator()(
            const parameters<parameter_type, parameter_count>& values
        ) const {
            static_cast<void>(values);
            return static_cast<parameter_type>(numerator) / static_cast<parameter_type>(denominator);
        }
    };

    template<
        typename parameter_type,
        unsigned long long int parameter_count,
        signed long long int whole,
        unsigned long long int decimal,
        unsigned long long int exponent
    >
    class real final {
    public:
        constexpr static const parameter_type value = [](){
            static const std::string string_whole = std::to_string(whole);
            static const std::string string_decimal = std::to_string(decimal);
            static const std::string string_exponent = std::to_string(exponent);
            return static_cast<parameter_type>(std::stod(string_whole + "." + string_decimal + "e" + string_exponent));
        }();
        constexpr inline const parameter_type& operator()(
            const parameters<parameter_type, parameter_count>& values
        ) const {
            static_cast<void>(values);
            return static_cast<parameter_type>(value);
        }
    };

    template<
        typename parameter_type,
        unsigned long long int parameter_count,
        unsigned int sign,
        unsigned int exponent,
        unsigned int mantissa
    >
    class real_float final {
    public:
        constexpr inline const parameter_type& operator()(
            const parameters<parameter_type, parameter_count>& values
        ) const {
            static_cast<void>(values);
            union {
                struct input {
                    unsigned int sign_part : 1;
                    unsigned int exponent_part : 8;
                    unsigned int mantissa_part : 23;
                };
                float output_value;
            } converter;
            converter.input.sign_part = sign;
            converter.input.exponent_part = exponent;
            converter.input.mantissa_part = mantissa;
            return static_cast<parameter_type>(converter.output_value);
        }
    };

    template<
        typename parameter_type,
        unsigned long long int parameter_count,
        unsigned long long int sign,
        unsigned long long int exponent,
        unsigned long long int mantissa
    >
    class real_double final {
    public:
        constexpr inline const parameter_type& operator()(
            const parameters<parameter_type, parameter_count>& values
            ) const {
            static_cast<void>(values);
            union {
                struct input {
                    unsigned long long int sign_part : 1;
                    unsigned long long int exponent_part : 11;
                    unsigned long long int mantissa_part : 52;
                };
                double output_value;
            } converter;
            converter.input.sign_part = sign;
            converter.input.exponent_part = exponent;
            converter.input.mantissa_part = mantissa;
            return static_cast<parameter_type>(converter.output_value);
        }
    };
#endif // ALTERNATIVES
}}

#endif // GTL_SYMBOLIC_HPP
