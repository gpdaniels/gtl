/*
Copyright (C) 2018-2024 Geoffrey Daniels. https://gpdaniels.com/

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, version 3 of the License only.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

#include <testbench/main.tests.hpp>

#include <testbench/comparison.tests.hpp>
#include <testbench/optimise.tests.hpp>
#include <testbench/require.tests.hpp>
#include <testbench/template.tests.hpp>

#include <hash/sha2>

#if defined(_MSC_VER)
#pragma warning(push, 0)
#endif

#include <cstdio>
#include <type_traits>

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

using sha2_types = testbench::value_collection<224, 256, 384, 512>;

TEST(sha2, traits, standard) {
    testbench::test_template<sha2_types>(
        [](auto test_value) -> void {
            constexpr static const unsigned long long int value = decltype(test_value)::value;

            REQUIRE((std::is_pod<gtl::sha2<value>>::value == false));

            REQUIRE((std::is_trivial<gtl::sha2<value>>::value == false));

            REQUIRE((std::is_trivially_copyable<gtl::sha2<value>>::value == true));

            REQUIRE((std::is_standard_layout<gtl::sha2<value>>::value == true));
        }
    );
}

TEST(sha2, constructor, empty) {
    testbench::test_template<sha2_types>(
        [](auto test_value) -> void {
            constexpr static const unsigned long long int value = decltype(test_value)::value;
            gtl::sha2<value> sha2;
            testbench::do_not_optimise_away(sha2);
        }
    );
}

TEST(sha2, function, reset) {
    testbench::test_template<sha2_types>(
        [](auto test_value) -> void {
            constexpr static const unsigned long long int value = decltype(test_value)::value;
            gtl::sha2<value> sha2;
            sha2.reset();
        }
    );
}

TEST(sha2, function, consume) {
    testbench::test_template<sha2_types>(
        [](auto test_value) -> void {
            constexpr static const unsigned long long int value = decltype(test_value)::value;
            gtl::sha2<value> sha2;
            sha2.consume("", 0);
            sha2.consume("123456781234567812345678123456781234567812345678123456781234567", 63);
            sha2.consume("1234567812345678123456781234567812345678123456781234567812345678", 64);
            sha2.consume("12345678123456781234567812345678123456781234567812345678123456781", 65);
        }
    );
}

TEST(sha2, function, finalise) {
    testbench::test_template<sha2_types>(
        [](auto test_value) -> void {
            constexpr static const unsigned long long int value = decltype(test_value)::value;
            gtl::sha2<value> sha2;
            sha2.finalise();
        }
    );
}

TEST(sha2, function, get_hash) {
    testbench::test_template<sha2_types>(
        [](auto test_value) -> void {
            constexpr static const unsigned long long int value = decltype(test_value)::value;
            gtl::sha2<value> sha2;
            sha2.finalise();
            sha2.get_hash();
        }
    );
}

TEST(sha2, function, hash) {
    testbench::test_template<sha2_types>(
        [](auto test_value) -> void {
            constexpr static const unsigned long long int value = decltype(test_value)::value;
            gtl::sha2<value>::hash("", 0);
            gtl::sha2<value>::hash("123456781234567812345678123456781234567812345678123456781234567", 63);
            gtl::sha2<value>::hash("1234567812345678123456781234567812345678123456781234567812345678", 64);
            gtl::sha2<value>::hash("12345678123456781234567812345678123456781234567812345678123456781", 65);
        }
    );
}

TEST(sha2, evaluate, hash_as_integer) {
    constexpr static const unsigned int data_count = 7;

    constexpr static const char* data[data_count] = {
        "",
        "a",
        "abc",
        "message digest",
        "abcdefghijklmnopqrstuvwxyz",
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
        "12345678901234567890123456789012345678901234567890123456789012345678901234567890"
    };
    UNUSED(data);

    constexpr static const unsigned char result_sha2_224[data_count][gtl::sha2<224>::hash_size] = {
        { 0xD1, 0x4A, 0x02, 0x8C, 0x2A, 0x3A, 0x2B, 0xC9, 0x47, 0x61, 0x02, 0xBB, 0x28, 0x82, 0x34, 0xC4, 0x15, 0xA2, 0xB0, 0x1F, 0x82, 0x8E, 0xA6, 0x2A, 0xC5, 0xB3, 0xE4, 0x2F },
        { 0xAB, 0xD3, 0x75, 0x34, 0xC7, 0xD9, 0xA2, 0xEF, 0xB9, 0x46, 0x5D, 0xE9, 0x31, 0xCD, 0x70, 0x55, 0xFF, 0xDB, 0x88, 0x79, 0x56, 0x3A, 0xE9, 0x80, 0x78, 0xD6, 0xD6, 0xD5 },
        { 0x23, 0x09, 0x7D, 0x22, 0x34, 0x05, 0xD8, 0x22, 0x86, 0x42, 0xA4, 0x77, 0xBD, 0xA2, 0x55, 0xB3, 0x2A, 0xAD, 0xBC, 0xE4, 0xBD, 0xA0, 0xB3, 0xF7, 0xE3, 0x6C, 0x9D, 0xA7 },
        { 0x2C, 0xB2, 0x1C, 0x83, 0xAE, 0x2F, 0x00, 0x4D, 0xE7, 0xE8, 0x1C, 0x3C, 0x70, 0x19, 0xCB, 0xCB, 0x65, 0xB7, 0x1A, 0xB6, 0x56, 0xB2, 0x2D, 0x6D, 0x0C, 0x39, 0xB8, 0xEB },
        { 0x45, 0xA5, 0xF7, 0x2C, 0x39, 0xC5, 0xCF, 0xF2, 0x52, 0x2E, 0xB3, 0x42, 0x97, 0x99, 0xE4, 0x9E, 0x5F, 0x44, 0xB3, 0x56, 0xEF, 0x92, 0x6B, 0xCF, 0x39, 0x0D, 0xCC, 0xC2 },
        { 0xBF, 0xF7, 0x2B, 0x4F, 0xCB, 0x7D, 0x75, 0xE5, 0x63, 0x29, 0x00, 0xAC, 0x5F, 0x90, 0xD2, 0x19, 0xE0, 0x5E, 0x97, 0xA7, 0xBD, 0xE7, 0x2E, 0x74, 0x0D, 0xB3, 0x93, 0xD9 },
        { 0xB5, 0x0A, 0xEC, 0xBE, 0x4E, 0x9B, 0xB0, 0xB5, 0x7B, 0xC5, 0xF3, 0xAE, 0x76, 0x0A, 0x8E, 0x01, 0xDB, 0x24, 0xF2, 0x03, 0xFB, 0x3C, 0xDC, 0xD1, 0x31, 0x48, 0x04, 0x6E }
    };
    UNUSED(result_sha2_224);

    constexpr static const unsigned char result_sha2_256[data_count][gtl::sha2<256>::hash_size] = {
        { 0xE3, 0xB0, 0xC4, 0x42, 0x98, 0xFC, 0x1C, 0x14, 0x9A, 0xFB, 0xF4, 0xC8, 0x99, 0x6F, 0xB9, 0x24, 0x27, 0xAE, 0x41, 0xE4, 0x64, 0x9B, 0x93, 0x4C, 0xA4, 0x95, 0x99, 0x1B, 0x78, 0x52, 0xB8, 0x55 },
        { 0xCA, 0x97, 0x81, 0x12, 0xCA, 0x1B, 0xBD, 0xCA, 0xFA, 0xC2, 0x31, 0xB3, 0x9A, 0x23, 0xDC, 0x4D, 0xA7, 0x86, 0xEF, 0xF8, 0x14, 0x7C, 0x4E, 0x72, 0xB9, 0x80, 0x77, 0x85, 0xAF, 0xEE, 0x48, 0xBB },
        { 0xBA, 0x78, 0x16, 0xBF, 0x8F, 0x01, 0xCF, 0xEA, 0x41, 0x41, 0x40, 0xDE, 0x5D, 0xAE, 0x22, 0x23, 0xB0, 0x03, 0x61, 0xA3, 0x96, 0x17, 0x7A, 0x9C, 0xB4, 0x10, 0xFF, 0x61, 0xF2, 0x00, 0x15, 0xAD },
        { 0xF7, 0x84, 0x6F, 0x55, 0xCF, 0x23, 0xE1, 0x4E, 0xEB, 0xEA, 0xB5, 0xB4, 0xE1, 0x55, 0x0C, 0xAD, 0x5B, 0x50, 0x9E, 0x33, 0x48, 0xFB, 0xC4, 0xEF, 0xA3, 0xA1, 0x41, 0x3D, 0x39, 0x3C, 0xB6, 0x50 },
        { 0x71, 0xC4, 0x80, 0xDF, 0x93, 0xD6, 0xAE, 0x2F, 0x1E, 0xFA, 0xD1, 0x44, 0x7C, 0x66, 0xC9, 0x52, 0x5E, 0x31, 0x62, 0x18, 0xCF, 0x51, 0xFC, 0x8D, 0x9E, 0xD8, 0x32, 0xF2, 0xDA, 0xF1, 0x8B, 0x73 },
        { 0xDB, 0x4B, 0xFC, 0xBD, 0x4D, 0xA0, 0xCD, 0x85, 0xA6, 0x0C, 0x3C, 0x37, 0xD3, 0xFB, 0xD8, 0x80, 0x5C, 0x77, 0xF1, 0x5F, 0xC6, 0xB1, 0xFD, 0xFE, 0x61, 0x4E, 0xE0, 0xA7, 0xC8, 0xFD, 0xB4, 0xC0 },
        { 0xF3, 0x71, 0xBC, 0x4A, 0x31, 0x1F, 0x2B, 0x00, 0x9E, 0xEF, 0x95, 0x2D, 0xD8, 0x3C, 0xA8, 0x0E, 0x2B, 0x60, 0x02, 0x6C, 0x8E, 0x93, 0x55, 0x92, 0xD0, 0xF9, 0xC3, 0x08, 0x45, 0x3C, 0x81, 0x3E }
    };
    UNUSED(result_sha2_256);

    constexpr static const unsigned char result_sha2_384[data_count][gtl::sha2<384>::hash_size] = {
        { 0x38, 0xB0, 0x60, 0xA7, 0x51, 0xAC, 0x96, 0x38, 0x4C, 0xD9, 0x32, 0x7E, 0xB1, 0xB1, 0xE3, 0x6A, 0x21, 0xFD, 0xB7, 0x11, 0x14, 0xBE, 0x07, 0x43, 0x4C, 0x0C, 0xC7, 0xBF, 0x63, 0xF6, 0xE1, 0xDA, 0x27, 0x4E, 0xDE, 0xBF, 0xE7, 0x6F, 0x65, 0xFB, 0xD5, 0x1A, 0xD2, 0xF1, 0x48, 0x98, 0xB9, 0x5B },
        { 0x54, 0xA5, 0x9B, 0x9F, 0x22, 0xB0, 0xB8, 0x08, 0x80, 0xD8, 0x42, 0x7E, 0x54, 0x8B, 0x7C, 0x23, 0xAB, 0xD8, 0x73, 0x48, 0x6E, 0x1F, 0x03, 0x5D, 0xCE, 0x9C, 0xD6, 0x97, 0xE8, 0x51, 0x75, 0x03, 0x3C, 0xAA, 0x88, 0xE6, 0xD5, 0x7B, 0xC3, 0x5E, 0xFA, 0xE0, 0xB5, 0xAF, 0xD3, 0x14, 0x5F, 0x31 },
        { 0xCB, 0x00, 0x75, 0x3F, 0x45, 0xA3, 0x5E, 0x8B, 0xB5, 0xA0, 0x3D, 0x69, 0x9A, 0xC6, 0x50, 0x07, 0x27, 0x2C, 0x32, 0xAB, 0x0E, 0xDE, 0xD1, 0x63, 0x1A, 0x8B, 0x60, 0x5A, 0x43, 0xFF, 0x5B, 0xED, 0x80, 0x86, 0x07, 0x2B, 0xA1, 0xE7, 0xCC, 0x23, 0x58, 0xBA, 0xEC, 0xA1, 0x34, 0xC8, 0x25, 0xA7 },
        { 0x47, 0x3E, 0xD3, 0x51, 0x67, 0xEC, 0x1F, 0x5D, 0x8E, 0x55, 0x03, 0x68, 0xA3, 0xDB, 0x39, 0xBE, 0x54, 0x63, 0x9F, 0x82, 0x88, 0x68, 0xE9, 0x45, 0x4C, 0x23, 0x9F, 0xC8, 0xB5, 0x2E, 0x3C, 0x61, 0xDB, 0xD0, 0xD8, 0xB4, 0xDE, 0x13, 0x90, 0xC2, 0x56, 0xDC, 0xBB, 0x5D, 0x5F, 0xD9, 0x9C, 0xD5 },
        { 0xFE, 0xB6, 0x73, 0x49, 0xDF, 0x3D, 0xB6, 0xF5, 0x92, 0x48, 0x15, 0xD6, 0xC3, 0xDC, 0x13, 0x3F, 0x09, 0x18, 0x09, 0x21, 0x37, 0x31, 0xFE, 0x5C, 0x7B, 0x5F, 0x49, 0x99, 0xE4, 0x63, 0x47, 0x9F, 0xF2, 0x87, 0x7F, 0x5F, 0x29, 0x36, 0xFA, 0x63, 0xBB, 0x43, 0x78, 0x4B, 0x12, 0xF3, 0xEB, 0xB4 },
        { 0x17, 0x61, 0x33, 0x6E, 0x3F, 0x7C, 0xBF, 0xE5, 0x1D, 0xEB, 0x13, 0x7F, 0x02, 0x6F, 0x89, 0xE0, 0x1A, 0x44, 0x8E, 0x3B, 0x1F, 0xAF, 0xA6, 0x40, 0x39, 0xC1, 0x46, 0x4E, 0xE8, 0x73, 0x2F, 0x11, 0xA5, 0x34, 0x1A, 0x6F, 0x41, 0xE0, 0xC2, 0x02, 0x29, 0x47, 0x36, 0xED, 0x64, 0xDB, 0x1A, 0x84 },
        { 0xB1, 0x29, 0x32, 0xB0, 0x62, 0x7D, 0x1C, 0x06, 0x09, 0x42, 0xF5, 0x44, 0x77, 0x64, 0x15, 0x56, 0x55, 0xBD, 0x4D, 0xA0, 0xC9, 0xAF, 0xA6, 0xDD, 0x9B, 0x9E, 0xF5, 0x31, 0x29, 0xAF, 0x1B, 0x8F, 0xB0, 0x19, 0x59, 0x96, 0xD2, 0xDE, 0x9C, 0xA0, 0xDF, 0x9D, 0x82, 0x1F, 0xFE, 0xE6, 0x70, 0x26 }
    };
    UNUSED(result_sha2_384);

    constexpr static const unsigned char result_sha2_512[data_count][gtl::sha2<512>::hash_size] = {
        { 0xCF, 0x83, 0xE1, 0x35, 0x7E, 0xEF, 0xB8, 0xBD, 0xF1, 0x54, 0x28, 0x50, 0xD6, 0x6D, 0x80, 0x07, 0xD6, 0x20, 0xE4, 0x05, 0x0B, 0x57, 0x15, 0xDC, 0x83, 0xF4, 0xA9, 0x21, 0xD3, 0x6C, 0xE9, 0xCE, 0x47, 0xD0, 0xD1, 0x3C, 0x5D, 0x85, 0xF2, 0xB0, 0xFF, 0x83, 0x18, 0xD2, 0x87, 0x7E, 0xEC, 0x2F, 0x63, 0xB9, 0x31, 0xBD, 0x47, 0x41, 0x7A, 0x81, 0xA5, 0x38, 0x32, 0x7A, 0xF9, 0x27, 0xDA, 0x3E },
        { 0x1F, 0x40, 0xFC, 0x92, 0xDA, 0x24, 0x16, 0x94, 0x75, 0x09, 0x79, 0xEE, 0x6C, 0xF5, 0x82, 0xF2, 0xD5, 0xD7, 0xD2, 0x8E, 0x18, 0x33, 0x5D, 0xE0, 0x5A, 0xBC, 0x54, 0xD0, 0x56, 0x0E, 0x0F, 0x53, 0x02, 0x86, 0x0C, 0x65, 0x2B, 0xF0, 0x8D, 0x56, 0x02, 0x52, 0xAA, 0x5E, 0x74, 0x21, 0x05, 0x46, 0xF3, 0x69, 0xFB, 0xBB, 0xCE, 0x8C, 0x12, 0xCF, 0xC7, 0x95, 0x7B, 0x26, 0x52, 0xFE, 0x9A, 0x75 },
        { 0xDD, 0xAF, 0x35, 0xA1, 0x93, 0x61, 0x7A, 0xBA, 0xCC, 0x41, 0x73, 0x49, 0xAE, 0x20, 0x41, 0x31, 0x12, 0xE6, 0xFA, 0x4E, 0x89, 0xA9, 0x7E, 0xA2, 0x0A, 0x9E, 0xEE, 0xE6, 0x4B, 0x55, 0xD3, 0x9A, 0x21, 0x92, 0x99, 0x2A, 0x27, 0x4F, 0xC1, 0xA8, 0x36, 0xBA, 0x3C, 0x23, 0xA3, 0xFE, 0xEB, 0xBD, 0x45, 0x4D, 0x44, 0x23, 0x64, 0x3C, 0xE8, 0x0E, 0x2A, 0x9A, 0xC9, 0x4F, 0xA5, 0x4C, 0xA4, 0x9F },
        { 0x10, 0x7D, 0xBF, 0x38, 0x9D, 0x9E, 0x9F, 0x71, 0xA3, 0xA9, 0x5F, 0x6C, 0x05, 0x5B, 0x92, 0x51, 0xBC, 0x52, 0x68, 0xC2, 0xBE, 0x16, 0xD6, 0xC1, 0x34, 0x92, 0xEA, 0x45, 0xB0, 0x19, 0x9F, 0x33, 0x09, 0xE1, 0x64, 0x55, 0xAB, 0x1E, 0x96, 0x11, 0x8E, 0x8A, 0x90, 0x5D, 0x55, 0x97, 0xB7, 0x20, 0x38, 0xDD, 0xB3, 0x72, 0xA8, 0x98, 0x26, 0x04, 0x6D, 0xE6, 0x66, 0x87, 0xBB, 0x42, 0x0E, 0x7C },
        { 0x4D, 0xBF, 0xF8, 0x6C, 0xC2, 0xCA, 0x1B, 0xAE, 0x1E, 0x16, 0x46, 0x8A, 0x05, 0xCB, 0x98, 0x81, 0xC9, 0x7F, 0x17, 0x53, 0xBC, 0xE3, 0x61, 0x90, 0x34, 0x89, 0x8F, 0xAA, 0x1A, 0xAB, 0xE4, 0x29, 0x95, 0x5A, 0x1B, 0xF8, 0xEC, 0x48, 0x3D, 0x74, 0x21, 0xFE, 0x3C, 0x16, 0x46, 0x61, 0x3A, 0x59, 0xED, 0x54, 0x41, 0xFB, 0x0F, 0x32, 0x13, 0x89, 0xF7, 0x7F, 0x48, 0xA8, 0x79, 0xC7, 0xB1, 0xF1 },
        { 0x1E, 0x07, 0xBE, 0x23, 0xC2, 0x6A, 0x86, 0xEA, 0x37, 0xEA, 0x81, 0x0C, 0x8E, 0xC7, 0x80, 0x93, 0x52, 0x51, 0x5A, 0x97, 0x0E, 0x92, 0x53, 0xC2, 0x6F, 0x53, 0x6C, 0xFC, 0x7A, 0x99, 0x96, 0xC4, 0x5C, 0x83, 0x70, 0x58, 0x3E, 0x0A, 0x78, 0xFA, 0x4A, 0x90, 0x04, 0x1D, 0x71, 0xA4, 0xCE, 0xAB, 0x74, 0x23, 0xF1, 0x9C, 0x71, 0xB9, 0xD5, 0xA3, 0xE0, 0x12, 0x49, 0xF0, 0xBE, 0xBD, 0x58, 0x94 },
        { 0x72, 0xEC, 0x1E, 0xF1, 0x12, 0x4A, 0x45, 0xB0, 0x47, 0xE8, 0xB7, 0xC7, 0x5A, 0x93, 0x21, 0x95, 0x13, 0x5B, 0xB6, 0x1D, 0xE2, 0x4E, 0xC0, 0xD1, 0x91, 0x40, 0x42, 0x24, 0x6E, 0x0A, 0xEC, 0x3A, 0x23, 0x54, 0xE0, 0x93, 0xD7, 0x6F, 0x30, 0x48, 0xB4, 0x56, 0x76, 0x43, 0x46, 0x90, 0x0C, 0xB1, 0x30, 0xD2, 0xA4, 0xFD, 0x5D, 0xD1, 0x6A, 0xBB, 0x5E, 0x30, 0xBC, 0xB8, 0x50, 0xDE, 0xE8, 0x43 }
    };
    UNUSED(result_sha2_512);

    testbench::test_template<sha2_types>(
        [](auto test_value) -> void {
            constexpr static const unsigned long long int value = decltype(test_value)::value;

            gtl::sha2<value> sha2;

            for (unsigned int i = 0; i < data_count; ++i) {
                sha2.reset();
                sha2.consume(data[i], testbench::string_length(data[i]));
                sha2.finalise();
                typename gtl::sha2<value>::hash_type hash = sha2.get_hash();

                char hash_string[(2 * gtl::sha2<value>::hash_size) + 1] = {};
                char result_string[(2 * gtl::sha2<value>::hash_size) + 1] = {};
                for (size_t index = 0; index < gtl::sha2<value>::hash_size; ++index) {
                    snprintf(hash_string + (index * 2), 3, "%02X", hash.data[index]);
                    if constexpr (value == 224) {
                        snprintf(result_string + (index * 2), 3, "%02X", result_sha2_224[i][index]);
                    }
                    else if constexpr (value == 256) {
                        snprintf(result_string + (index * 2), 3, "%02X", result_sha2_256[i][index]);
                    }
                    else if constexpr (value == 384) {
                        snprintf(result_string + (index * 2), 3, "%02X", result_sha2_384[i][index]);
                    }
                    else if constexpr (value == 512) {
                        snprintf(result_string + (index * 2), 3, "%02X", result_sha2_512[i][index]);
                    }
                    else {
                        REQUIRE(false);
                    }
                }
                PRINT("%s == %s\n", hash_string, result_string);
                if constexpr (value == 224) {
                    REQUIRE(testbench::is_memory_same(hash.data, result_sha2_224[i], gtl::sha2<value>::hash_size) == true);
                }
                else if constexpr (value == 256) {
                    REQUIRE(testbench::is_memory_same(hash.data, result_sha2_256[i], gtl::sha2<value>::hash_size) == true);
                }
                else if constexpr (value == 384) {
                    REQUIRE(testbench::is_memory_same(hash.data, result_sha2_384[i], gtl::sha2<value>::hash_size) == true);
                }
                else if constexpr (value == 512) {
                    REQUIRE(testbench::is_memory_same(hash.data, result_sha2_512[i], gtl::sha2<value>::hash_size) == true);
                }
                else {
                    REQUIRE(false);
                }
            }
        }
    );
}

TEST(sha2, evaluate, hash_as_string) {
    constexpr static const unsigned int hash_count = 4;
    constexpr static const unsigned int data_count = 7;

    constexpr static const char* data[data_count] = {
        "",
        "a",
        "abc",
        "message digest",
        "abcdefghijklmnopqrstuvwxyz",
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
        "12345678901234567890123456789012345678901234567890123456789012345678901234567890"
    };
    UNUSED(data);

    constexpr static const char* result[hash_count][data_count] = {
        { // 224
          "D14A028C2A3A2BC9476102BB288234C415A2B01F828EA62AC5B3E42F",
          "ABD37534C7D9A2EFB9465DE931CD7055FFDB8879563AE98078D6D6D5",
          "23097D223405D8228642A477BDA255B32AADBCE4BDA0B3F7E36C9DA7",
          "2CB21C83AE2F004DE7E81C3C7019CBCB65B71AB656B22D6D0C39B8EB",
          "45A5F72C39C5CFF2522EB3429799E49E5F44B356EF926BCF390DCCC2",
          "BFF72B4FCB7D75E5632900AC5F90D219E05E97A7BDE72E740DB393D9",
          "B50AECBE4E9BB0B57BC5F3AE760A8E01DB24F203FB3CDCD13148046E" },
        { // 256
          "E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855",
          "CA978112CA1BBDCAFAC231B39A23DC4DA786EFF8147C4E72B9807785AFEE48BB",
          "BA7816BF8F01CFEA414140DE5DAE2223B00361A396177A9CB410FF61F20015AD",
          "F7846F55CF23E14EEBEAB5B4E1550CAD5B509E3348FBC4EFA3A1413D393CB650",
          "71C480DF93D6AE2F1EFAD1447C66C9525E316218CF51FC8D9ED832F2DAF18B73",
          "DB4BFCBD4DA0CD85A60C3C37D3FBD8805C77F15FC6B1FDFE614EE0A7C8FDB4C0",
          "F371BC4A311F2B009EEF952DD83CA80E2B60026C8E935592D0F9C308453C813E" },
        { // 382
          "38B060A751AC96384CD9327EB1B1E36A21FDB71114BE07434C0CC7BF63F6E1DA274EDEBFE76F65FBD51AD2F14898B95B",
          "54A59B9F22B0B80880D8427E548B7C23ABD873486E1F035DCE9CD697E85175033CAA88E6D57BC35EFAE0B5AFD3145F31",
          "CB00753F45A35E8BB5A03D699AC65007272C32AB0EDED1631A8B605A43FF5BED8086072BA1E7CC2358BAECA134C825A7",
          "473ED35167EC1F5D8E550368A3DB39BE54639F828868E9454C239FC8B52E3C61DBD0D8B4DE1390C256DCBB5D5FD99CD5",
          "FEB67349DF3DB6F5924815D6C3DC133F091809213731FE5C7B5F4999E463479FF2877F5F2936FA63BB43784B12F3EBB4",
          "1761336E3F7CBFE51DEB137F026F89E01A448E3B1FAFA64039C1464EE8732F11A5341A6F41E0C202294736ED64DB1A84",
          "B12932B0627D1C060942F5447764155655BD4DA0C9AFA6DD9B9EF53129AF1B8FB0195996D2DE9CA0DF9D821FFEE67026" },
        { // 512
          "CF83E1357EEFB8BDF1542850D66D8007D620E4050B5715DC83F4A921D36CE9CE47D0D13C5D85F2B0FF8318D2877EEC2F63B931BD47417A81A538327AF927DA3E",
          "1F40FC92DA241694750979EE6CF582F2D5D7D28E18335DE05ABC54D0560E0F5302860C652BF08D560252AA5E74210546F369FBBBCE8C12CFC7957B2652FE9A75",
          "DDAF35A193617ABACC417349AE20413112E6FA4E89A97EA20A9EEEE64B55D39A2192992A274FC1A836BA3C23A3FEEBBD454D4423643CE80E2A9AC94FA54CA49F",
          "107DBF389D9E9F71A3A95F6C055B9251BC5268C2BE16D6C13492EA45B0199F3309E16455AB1E96118E8A905D5597B72038DDB372A89826046DE66687BB420E7C",
          "4DBFF86CC2CA1BAE1E16468A05CB9881C97F1753BCE3619034898FAA1AABE429955A1BF8EC483D7421FE3C1646613A59ED5441FB0F321389F77F48A879C7B1F1",
          "1E07BE23C26A86EA37EA810C8EC7809352515A970E9253C26F536CFC7A9996C45C8370583E0A78FA4A90041D71A4CEAB7423F19C71B9D5A3E01249F0BEBD5894",
          "72EC1EF1124A45B047E8B7C75A932195135BB61DE24EC0D1914042246E0AEC3A2354E093D76F3048B456764346900CB130D2A4FD5DD16ABB5E30BCB850DEE843" }
    };
    UNUSED(result);

    testbench::test_template<sha2_types>(
        [](auto test_value) -> void {
            constexpr static const unsigned long long int value = decltype(test_value)::value;

            gtl::sha2<value> sha2;
            for (unsigned int i = 0; i < data_count; ++i) {
                sha2.reset();
                sha2.consume(data[i], testbench::string_length(data[i]));
                sha2.finalise();
                typename gtl::sha2<value>::hash_type hash = sha2.get_hash();

                unsigned long long int result_index = value == 512 ? 3 : value == 384 ? 2
                                                                     : value == 256   ? 1
                                                                                      : 0;

                PRINT("%s == %s\n", gtl::sha2<value>::hash_to_string(hash).hash, result[result_index][i]);
                REQUIRE(testbench::is_string_same(gtl::sha2<value>::hash_to_string(hash).hash, result[result_index][i]) == true);
            }
        }
    );
}

TEST(sha2, evaluate, partial_insert) {
    constexpr static const unsigned int data_count = 7;

    constexpr static const char* data1[data_count] = {
        "",
        "a",
        "",
        "message",
        "abcdefghijklm",
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
        "123456789012345678901234567890123456789012345678901234567890"
    };
    UNUSED(data1);

    constexpr static const char* data2[data_count] = {
        "",
        "",
        "abc",
        " digest",
        "nopqrstuvwxyz",
        "",
        "12345678901234567890"
    };
    UNUSED(data2);

    constexpr static const unsigned char result_sha2_224[data_count][gtl::sha2<224>::hash_size] = {
        { 0xD1, 0x4A, 0x02, 0x8C, 0x2A, 0x3A, 0x2B, 0xC9, 0x47, 0x61, 0x02, 0xBB, 0x28, 0x82, 0x34, 0xC4, 0x15, 0xA2, 0xB0, 0x1F, 0x82, 0x8E, 0xA6, 0x2A, 0xC5, 0xB3, 0xE4, 0x2F },
        { 0xAB, 0xD3, 0x75, 0x34, 0xC7, 0xD9, 0xA2, 0xEF, 0xB9, 0x46, 0x5D, 0xE9, 0x31, 0xCD, 0x70, 0x55, 0xFF, 0xDB, 0x88, 0x79, 0x56, 0x3A, 0xE9, 0x80, 0x78, 0xD6, 0xD6, 0xD5 },
        { 0x23, 0x09, 0x7D, 0x22, 0x34, 0x05, 0xD8, 0x22, 0x86, 0x42, 0xA4, 0x77, 0xBD, 0xA2, 0x55, 0xB3, 0x2A, 0xAD, 0xBC, 0xE4, 0xBD, 0xA0, 0xB3, 0xF7, 0xE3, 0x6C, 0x9D, 0xA7 },
        { 0x2C, 0xB2, 0x1C, 0x83, 0xAE, 0x2F, 0x00, 0x4D, 0xE7, 0xE8, 0x1C, 0x3C, 0x70, 0x19, 0xCB, 0xCB, 0x65, 0xB7, 0x1A, 0xB6, 0x56, 0xB2, 0x2D, 0x6D, 0x0C, 0x39, 0xB8, 0xEB },
        { 0x45, 0xA5, 0xF7, 0x2C, 0x39, 0xC5, 0xCF, 0xF2, 0x52, 0x2E, 0xB3, 0x42, 0x97, 0x99, 0xE4, 0x9E, 0x5F, 0x44, 0xB3, 0x56, 0xEF, 0x92, 0x6B, 0xCF, 0x39, 0x0D, 0xCC, 0xC2 },
        { 0xBF, 0xF7, 0x2B, 0x4F, 0xCB, 0x7D, 0x75, 0xE5, 0x63, 0x29, 0x00, 0xAC, 0x5F, 0x90, 0xD2, 0x19, 0xE0, 0x5E, 0x97, 0xA7, 0xBD, 0xE7, 0x2E, 0x74, 0x0D, 0xB3, 0x93, 0xD9 },
        { 0xB5, 0x0A, 0xEC, 0xBE, 0x4E, 0x9B, 0xB0, 0xB5, 0x7B, 0xC5, 0xF3, 0xAE, 0x76, 0x0A, 0x8E, 0x01, 0xDB, 0x24, 0xF2, 0x03, 0xFB, 0x3C, 0xDC, 0xD1, 0x31, 0x48, 0x04, 0x6E }
    };
    UNUSED(result_sha2_224);

    constexpr static const unsigned char result_sha2_256[data_count][gtl::sha2<256>::hash_size] = {
        { 0xE3, 0xB0, 0xC4, 0x42, 0x98, 0xFC, 0x1C, 0x14, 0x9A, 0xFB, 0xF4, 0xC8, 0x99, 0x6F, 0xB9, 0x24, 0x27, 0xAE, 0x41, 0xE4, 0x64, 0x9B, 0x93, 0x4C, 0xA4, 0x95, 0x99, 0x1B, 0x78, 0x52, 0xB8, 0x55 },
        { 0xCA, 0x97, 0x81, 0x12, 0xCA, 0x1B, 0xBD, 0xCA, 0xFA, 0xC2, 0x31, 0xB3, 0x9A, 0x23, 0xDC, 0x4D, 0xA7, 0x86, 0xEF, 0xF8, 0x14, 0x7C, 0x4E, 0x72, 0xB9, 0x80, 0x77, 0x85, 0xAF, 0xEE, 0x48, 0xBB },
        { 0xBA, 0x78, 0x16, 0xBF, 0x8F, 0x01, 0xCF, 0xEA, 0x41, 0x41, 0x40, 0xDE, 0x5D, 0xAE, 0x22, 0x23, 0xB0, 0x03, 0x61, 0xA3, 0x96, 0x17, 0x7A, 0x9C, 0xB4, 0x10, 0xFF, 0x61, 0xF2, 0x00, 0x15, 0xAD },
        { 0xF7, 0x84, 0x6F, 0x55, 0xCF, 0x23, 0xE1, 0x4E, 0xEB, 0xEA, 0xB5, 0xB4, 0xE1, 0x55, 0x0C, 0xAD, 0x5B, 0x50, 0x9E, 0x33, 0x48, 0xFB, 0xC4, 0xEF, 0xA3, 0xA1, 0x41, 0x3D, 0x39, 0x3C, 0xB6, 0x50 },
        { 0x71, 0xC4, 0x80, 0xDF, 0x93, 0xD6, 0xAE, 0x2F, 0x1E, 0xFA, 0xD1, 0x44, 0x7C, 0x66, 0xC9, 0x52, 0x5E, 0x31, 0x62, 0x18, 0xCF, 0x51, 0xFC, 0x8D, 0x9E, 0xD8, 0x32, 0xF2, 0xDA, 0xF1, 0x8B, 0x73 },
        { 0xDB, 0x4B, 0xFC, 0xBD, 0x4D, 0xA0, 0xCD, 0x85, 0xA6, 0x0C, 0x3C, 0x37, 0xD3, 0xFB, 0xD8, 0x80, 0x5C, 0x77, 0xF1, 0x5F, 0xC6, 0xB1, 0xFD, 0xFE, 0x61, 0x4E, 0xE0, 0xA7, 0xC8, 0xFD, 0xB4, 0xC0 },
        { 0xF3, 0x71, 0xBC, 0x4A, 0x31, 0x1F, 0x2B, 0x00, 0x9E, 0xEF, 0x95, 0x2D, 0xD8, 0x3C, 0xA8, 0x0E, 0x2B, 0x60, 0x02, 0x6C, 0x8E, 0x93, 0x55, 0x92, 0xD0, 0xF9, 0xC3, 0x08, 0x45, 0x3C, 0x81, 0x3E }
    };
    UNUSED(result_sha2_256);

    constexpr static const unsigned char result_sha2_384[data_count][gtl::sha2<384>::hash_size] = {
        { 0x38, 0xB0, 0x60, 0xA7, 0x51, 0xAC, 0x96, 0x38, 0x4C, 0xD9, 0x32, 0x7E, 0xB1, 0xB1, 0xE3, 0x6A, 0x21, 0xFD, 0xB7, 0x11, 0x14, 0xBE, 0x07, 0x43, 0x4C, 0x0C, 0xC7, 0xBF, 0x63, 0xF6, 0xE1, 0xDA, 0x27, 0x4E, 0xDE, 0xBF, 0xE7, 0x6F, 0x65, 0xFB, 0xD5, 0x1A, 0xD2, 0xF1, 0x48, 0x98, 0xB9, 0x5B },
        { 0x54, 0xA5, 0x9B, 0x9F, 0x22, 0xB0, 0xB8, 0x08, 0x80, 0xD8, 0x42, 0x7E, 0x54, 0x8B, 0x7C, 0x23, 0xAB, 0xD8, 0x73, 0x48, 0x6E, 0x1F, 0x03, 0x5D, 0xCE, 0x9C, 0xD6, 0x97, 0xE8, 0x51, 0x75, 0x03, 0x3C, 0xAA, 0x88, 0xE6, 0xD5, 0x7B, 0xC3, 0x5E, 0xFA, 0xE0, 0xB5, 0xAF, 0xD3, 0x14, 0x5F, 0x31 },
        { 0xCB, 0x00, 0x75, 0x3F, 0x45, 0xA3, 0x5E, 0x8B, 0xB5, 0xA0, 0x3D, 0x69, 0x9A, 0xC6, 0x50, 0x07, 0x27, 0x2C, 0x32, 0xAB, 0x0E, 0xDE, 0xD1, 0x63, 0x1A, 0x8B, 0x60, 0x5A, 0x43, 0xFF, 0x5B, 0xED, 0x80, 0x86, 0x07, 0x2B, 0xA1, 0xE7, 0xCC, 0x23, 0x58, 0xBA, 0xEC, 0xA1, 0x34, 0xC8, 0x25, 0xA7 },
        { 0x47, 0x3E, 0xD3, 0x51, 0x67, 0xEC, 0x1F, 0x5D, 0x8E, 0x55, 0x03, 0x68, 0xA3, 0xDB, 0x39, 0xBE, 0x54, 0x63, 0x9F, 0x82, 0x88, 0x68, 0xE9, 0x45, 0x4C, 0x23, 0x9F, 0xC8, 0xB5, 0x2E, 0x3C, 0x61, 0xDB, 0xD0, 0xD8, 0xB4, 0xDE, 0x13, 0x90, 0xC2, 0x56, 0xDC, 0xBB, 0x5D, 0x5F, 0xD9, 0x9C, 0xD5 },
        { 0xFE, 0xB6, 0x73, 0x49, 0xDF, 0x3D, 0xB6, 0xF5, 0x92, 0x48, 0x15, 0xD6, 0xC3, 0xDC, 0x13, 0x3F, 0x09, 0x18, 0x09, 0x21, 0x37, 0x31, 0xFE, 0x5C, 0x7B, 0x5F, 0x49, 0x99, 0xE4, 0x63, 0x47, 0x9F, 0xF2, 0x87, 0x7F, 0x5F, 0x29, 0x36, 0xFA, 0x63, 0xBB, 0x43, 0x78, 0x4B, 0x12, 0xF3, 0xEB, 0xB4 },
        { 0x17, 0x61, 0x33, 0x6E, 0x3F, 0x7C, 0xBF, 0xE5, 0x1D, 0xEB, 0x13, 0x7F, 0x02, 0x6F, 0x89, 0xE0, 0x1A, 0x44, 0x8E, 0x3B, 0x1F, 0xAF, 0xA6, 0x40, 0x39, 0xC1, 0x46, 0x4E, 0xE8, 0x73, 0x2F, 0x11, 0xA5, 0x34, 0x1A, 0x6F, 0x41, 0xE0, 0xC2, 0x02, 0x29, 0x47, 0x36, 0xED, 0x64, 0xDB, 0x1A, 0x84 },
        { 0xB1, 0x29, 0x32, 0xB0, 0x62, 0x7D, 0x1C, 0x06, 0x09, 0x42, 0xF5, 0x44, 0x77, 0x64, 0x15, 0x56, 0x55, 0xBD, 0x4D, 0xA0, 0xC9, 0xAF, 0xA6, 0xDD, 0x9B, 0x9E, 0xF5, 0x31, 0x29, 0xAF, 0x1B, 0x8F, 0xB0, 0x19, 0x59, 0x96, 0xD2, 0xDE, 0x9C, 0xA0, 0xDF, 0x9D, 0x82, 0x1F, 0xFE, 0xE6, 0x70, 0x26 }
    };
    UNUSED(result_sha2_384);

    constexpr static const unsigned char result_sha2_512[data_count][gtl::sha2<512>::hash_size] = {
        { 0xCF, 0x83, 0xE1, 0x35, 0x7E, 0xEF, 0xB8, 0xBD, 0xF1, 0x54, 0x28, 0x50, 0xD6, 0x6D, 0x80, 0x07, 0xD6, 0x20, 0xE4, 0x05, 0x0B, 0x57, 0x15, 0xDC, 0x83, 0xF4, 0xA9, 0x21, 0xD3, 0x6C, 0xE9, 0xCE, 0x47, 0xD0, 0xD1, 0x3C, 0x5D, 0x85, 0xF2, 0xB0, 0xFF, 0x83, 0x18, 0xD2, 0x87, 0x7E, 0xEC, 0x2F, 0x63, 0xB9, 0x31, 0xBD, 0x47, 0x41, 0x7A, 0x81, 0xA5, 0x38, 0x32, 0x7A, 0xF9, 0x27, 0xDA, 0x3E },
        { 0x1F, 0x40, 0xFC, 0x92, 0xDA, 0x24, 0x16, 0x94, 0x75, 0x09, 0x79, 0xEE, 0x6C, 0xF5, 0x82, 0xF2, 0xD5, 0xD7, 0xD2, 0x8E, 0x18, 0x33, 0x5D, 0xE0, 0x5A, 0xBC, 0x54, 0xD0, 0x56, 0x0E, 0x0F, 0x53, 0x02, 0x86, 0x0C, 0x65, 0x2B, 0xF0, 0x8D, 0x56, 0x02, 0x52, 0xAA, 0x5E, 0x74, 0x21, 0x05, 0x46, 0xF3, 0x69, 0xFB, 0xBB, 0xCE, 0x8C, 0x12, 0xCF, 0xC7, 0x95, 0x7B, 0x26, 0x52, 0xFE, 0x9A, 0x75 },
        { 0xDD, 0xAF, 0x35, 0xA1, 0x93, 0x61, 0x7A, 0xBA, 0xCC, 0x41, 0x73, 0x49, 0xAE, 0x20, 0x41, 0x31, 0x12, 0xE6, 0xFA, 0x4E, 0x89, 0xA9, 0x7E, 0xA2, 0x0A, 0x9E, 0xEE, 0xE6, 0x4B, 0x55, 0xD3, 0x9A, 0x21, 0x92, 0x99, 0x2A, 0x27, 0x4F, 0xC1, 0xA8, 0x36, 0xBA, 0x3C, 0x23, 0xA3, 0xFE, 0xEB, 0xBD, 0x45, 0x4D, 0x44, 0x23, 0x64, 0x3C, 0xE8, 0x0E, 0x2A, 0x9A, 0xC9, 0x4F, 0xA5, 0x4C, 0xA4, 0x9F },
        { 0x10, 0x7D, 0xBF, 0x38, 0x9D, 0x9E, 0x9F, 0x71, 0xA3, 0xA9, 0x5F, 0x6C, 0x05, 0x5B, 0x92, 0x51, 0xBC, 0x52, 0x68, 0xC2, 0xBE, 0x16, 0xD6, 0xC1, 0x34, 0x92, 0xEA, 0x45, 0xB0, 0x19, 0x9F, 0x33, 0x09, 0xE1, 0x64, 0x55, 0xAB, 0x1E, 0x96, 0x11, 0x8E, 0x8A, 0x90, 0x5D, 0x55, 0x97, 0xB7, 0x20, 0x38, 0xDD, 0xB3, 0x72, 0xA8, 0x98, 0x26, 0x04, 0x6D, 0xE6, 0x66, 0x87, 0xBB, 0x42, 0x0E, 0x7C },
        { 0x4D, 0xBF, 0xF8, 0x6C, 0xC2, 0xCA, 0x1B, 0xAE, 0x1E, 0x16, 0x46, 0x8A, 0x05, 0xCB, 0x98, 0x81, 0xC9, 0x7F, 0x17, 0x53, 0xBC, 0xE3, 0x61, 0x90, 0x34, 0x89, 0x8F, 0xAA, 0x1A, 0xAB, 0xE4, 0x29, 0x95, 0x5A, 0x1B, 0xF8, 0xEC, 0x48, 0x3D, 0x74, 0x21, 0xFE, 0x3C, 0x16, 0x46, 0x61, 0x3A, 0x59, 0xED, 0x54, 0x41, 0xFB, 0x0F, 0x32, 0x13, 0x89, 0xF7, 0x7F, 0x48, 0xA8, 0x79, 0xC7, 0xB1, 0xF1 },
        { 0x1E, 0x07, 0xBE, 0x23, 0xC2, 0x6A, 0x86, 0xEA, 0x37, 0xEA, 0x81, 0x0C, 0x8E, 0xC7, 0x80, 0x93, 0x52, 0x51, 0x5A, 0x97, 0x0E, 0x92, 0x53, 0xC2, 0x6F, 0x53, 0x6C, 0xFC, 0x7A, 0x99, 0x96, 0xC4, 0x5C, 0x83, 0x70, 0x58, 0x3E, 0x0A, 0x78, 0xFA, 0x4A, 0x90, 0x04, 0x1D, 0x71, 0xA4, 0xCE, 0xAB, 0x74, 0x23, 0xF1, 0x9C, 0x71, 0xB9, 0xD5, 0xA3, 0xE0, 0x12, 0x49, 0xF0, 0xBE, 0xBD, 0x58, 0x94 },
        { 0x72, 0xEC, 0x1E, 0xF1, 0x12, 0x4A, 0x45, 0xB0, 0x47, 0xE8, 0xB7, 0xC7, 0x5A, 0x93, 0x21, 0x95, 0x13, 0x5B, 0xB6, 0x1D, 0xE2, 0x4E, 0xC0, 0xD1, 0x91, 0x40, 0x42, 0x24, 0x6E, 0x0A, 0xEC, 0x3A, 0x23, 0x54, 0xE0, 0x93, 0xD7, 0x6F, 0x30, 0x48, 0xB4, 0x56, 0x76, 0x43, 0x46, 0x90, 0x0C, 0xB1, 0x30, 0xD2, 0xA4, 0xFD, 0x5D, 0xD1, 0x6A, 0xBB, 0x5E, 0x30, 0xBC, 0xB8, 0x50, 0xDE, 0xE8, 0x43 }
    };
    UNUSED(result_sha2_512);

    testbench::test_template<sha2_types>(
        [](auto test_value) -> void {
            constexpr static const unsigned long long int value = decltype(test_value)::value;

            gtl::sha2<value> sha2;
            for (unsigned int i = 0; i < data_count; ++i) {
                sha2.reset();
                sha2.consume(data1[i], testbench::string_length(data1[i]));
                sha2.consume(data2[i], testbench::string_length(data2[i]));
                sha2.finalise();
                typename gtl::sha2<value>::hash_type hash = sha2.get_hash();

                char hash_string[(2 * gtl::sha2<value>::hash_size) + 1] = {};
                char result_string[(2 * gtl::sha2<value>::hash_size) + 1] = {};
                for (size_t index = 0; index < gtl::sha2<value>::hash_size; ++index) {
                    snprintf(hash_string + (index * 2), 3, "%02X", hash.data[index]);
                    if constexpr (value == 224) {
                        snprintf(result_string + (index * 2), 3, "%02X", result_sha2_224[i][index]);
                    }
                    else if constexpr (value == 256) {
                        snprintf(result_string + (index * 2), 3, "%02X", result_sha2_256[i][index]);
                    }
                    else if constexpr (value == 384) {
                        snprintf(result_string + (index * 2), 3, "%02X", result_sha2_384[i][index]);
                    }
                    else if constexpr (value == 512) {
                        snprintf(result_string + (index * 2), 3, "%02X", result_sha2_512[i][index]);
                    }
                    else {
                        REQUIRE(false);
                    }
                }
                PRINT("%s == %s\n", hash_string, result_string);
                if constexpr (value == 224) {
                    REQUIRE(testbench::is_memory_same(hash.data, result_sha2_224[i], gtl::sha2<value>::hash_size) == true);
                }
                else if constexpr (value == 256) {
                    REQUIRE(testbench::is_memory_same(hash.data, result_sha2_256[i], gtl::sha2<value>::hash_size) == true);
                }
                else if constexpr (value == 384) {
                    REQUIRE(testbench::is_memory_same(hash.data, result_sha2_384[i], gtl::sha2<value>::hash_size) == true);
                }
                else if constexpr (value == 512) {
                    REQUIRE(testbench::is_memory_same(hash.data, result_sha2_512[i], gtl::sha2<value>::hash_size) == true);
                }
                else {
                    REQUIRE(false);
                }
            }
        }
    );
}
