/*
Copyright (C) 2018-2024 Geoffrey Daniels. https://gpdaniels.com/

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, version 3 of the License only.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

#include <testbench/main.tests.hpp>

#include <testbench/optimise.tests.hpp>
#include <testbench/print.tests.hpp>
#include <testbench/require.tests.hpp>

#include <algorithm/astar>

#if defined(_MSC_VER)
#pragma warning(push, 0)
#endif

#include <algorithm>
#include <cmath>
#include <vector>

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

struct xy {
    int x, y;

    bool operator==(const xy& other) const {
        return ((this->x == other.x) && (this->y == other.y));
    }

    struct hash_function {
        std::size_t operator()(const xy& pos) const {
            std::size_t rowHash = std::hash<int>()(pos.x);
            std::size_t colHash = std::hash<int>()(pos.y) << 1;
            return rowHash ^ colHash;
        }
    };
};

struct map {
    constexpr static const int width = 10;
    constexpr static const int height = 10;
    bool grid[height][width] = {
        {1, 1, 0, 0, 0, 1, 1, 1, 0, 0},
        {1, 1, 0, 1, 1, 1, 0, 1, 0, 0},
        {0, 1, 0, 1, 0, 0, 0, 1, 0, 0},
        {0, 1, 0, 1, 0, 0, 0, 1, 0, 0},
        {0, 1, 1, 1, 0, 0, 0, 1, 1, 0},
        {0, 1, 1, 1, 0, 0, 0, 1, 1, 1},
        {0, 1, 1, 1, 1, 1, 0, 1, 0, 1},
        {0, 1, 1, 0, 0, 1, 0, 1, 0, 1},
        {0, 1, 1, 0, 0, 1, 1, 1, 0, 1},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 1}
    };

    std::vector<xy> get_moves(const xy& current) {
        std::vector<xy> result;
        result.reserve(4);
        result.push_back({ current.x - 1, current.y });
        result.push_back({ current.x + 1, current.y });
        result.push_back({ current.x, current.y - 1 });
        result.push_back({ current.x, current.y + 1 });
        result.erase(std::remove_if(result.begin(), result.end(), [this](const xy& node) {
                         if (node.x < 0)
                             return true;
                         if (node.x >= width)
                             return true;
                         if (node.y < 0)
                             return true;
                         if (node.y >= height)
                             return true;
                         if (this->grid[node.y][node.x] == false)
                             return true;
                         return false;
                     }),
                     result.end());
        return result;
    }

    void print(const xy& start, const xy& end, std::vector<xy> path = {}) {
        PRINT("#");
        for (int x = 0; x < width; ++x) {
            PRINT("#");
        }
        PRINT("#\n");
        for (int y = 0; y < height; ++y) {
            PRINT("#");
            for (int x = 0; x < width; ++x) {
                bool on_start = (x == start.x) && (y == start.y);
                bool on_end = (x == end.x) && (y == end.y);
                bool on_path = (std::find(path.begin(), path.end(), xy{ x, y }) != path.end());
                if (on_start) {
                    PRINT("S");
                    continue;
                }
                if (on_end) {
                    PRINT("E");
                    continue;
                }
                if (on_path) {
                    PRINT("o");
                    continue;
                }
                if (this->grid[y][x]) {
                    PRINT(" ");
                    continue;
                }
                PRINT("X");
            }
            PRINT("#\n");
        }
        PRINT("#");
        for (int x = 0; x < width; ++x) {
            PRINT("#");
        }
        PRINT("#\n");
        PRINT("\n");
    }
};

TEST(astar, evaluate, solve) {
    xy start = { 0, 0 };
    xy end = { 9, 9 };
    std::vector<xy> path;
    map maze;

    maze.print(start, end, path);

    gtl::astar<xy, float>::solve(
        start,
        end,
        [&maze](const xy& current) -> std::vector<xy> {
            return maze.get_moves(current);
        },
        [](const xy& current, const xy& target) -> float {
            const int dx = (current.x - target.x);
            const int dy = (current.y - target.y);
            return std::sqrt(static_cast<float>((dx * dx) + (dy * dy)));
        },
        path);

    maze.print(start, end, path);
}

struct map2 {
    constexpr static const int width = 500;
    constexpr static const int height = 500;
    int grid[height][width] = {};

    std::vector<xy> get_moves(const xy& current) {
        std::vector<xy> result;
        result.reserve(4);
        result.push_back({ current.x - 1, current.y });
        result.push_back({ current.x + 1, current.y });
        result.push_back({ current.x, current.y - 1 });
        result.push_back({ current.x, current.y + 1 });
        result.erase(std::remove_if(result.begin(), result.end(), [this](const xy& node) {
                         if (node.x < 0)
                             return true;
                         if (node.x >= width)
                             return true;
                         if (node.y < 0)
                             return true;
                         if (node.y >= height)
                             return true;
                         if (this->grid[node.y][node.x] == 0)
                             return true;
                         return false;
                     }),
                     result.end());
        return result;
    }

    void print(const xy& start, const xy& end, std::vector<xy> path = {}) {
        PRINT("#");
        for (int x = 0; x < width; ++x) {
            PRINT("#");
        }
        PRINT("#\n");
        for (int y = 0; y < height; ++y) {
            PRINT("#");
            for (int x = 0; x < width; ++x) {
                bool on_start = (x == start.x) && (y == start.y);
                bool on_end = (x == end.x) && (y == end.y);
                bool on_path = (std::find(path.begin(), path.end(), xy{ x, y }) != path.end());
                if (on_start) {
                    PRINT("S");
                    continue;
                }
                if (on_end) {
                    PRINT("E");
                    continue;
                }
                if (on_path) {
                    PRINT("%d", this->grid[y][x]);
                    continue;
                }
                if (this->grid[y][x]) {
                    PRINT(" ");
                    continue;
                }
                PRINT("X");
            }
            PRINT("#\n");
        }
        PRINT("#");
        for (int x = 0; x < width; ++x) {
            PRINT("#");
        }
        PRINT("#\n");
        PRINT("\n");
    }
};

TEST(astar, evaluate, solve_big) {
    const char* data[] = {
        "5965431295231274959859471916143233128326711395729192128364316532213221929918691297412714255729119678",
        "5571897338216218431415954149362624276359139213313969151416742291159728416827198123589199183154421441",
        "3171111816481142595911182373573161912252822129979242953221478138221541791599391292297963231851159431",
        "9912211892621122931135719915833918979685811292995911617199521191388755133362728179681718485233647194",
        "2987717117181921276421242757232451934721539188871562767329737971291989492419782719814733134234821933",
        "9891232431917289993316672595151742912432646712141912168416542141941216491869741913829123336917781131",
        "2698914787863913941391762518231717573495733231319567329146712118498191194315219217722234827598851193",
        "4283278171452331941533118839965433462226622832745718911759578161711723284741154292254247215947117574",
        "4729518876865318339218246659989198519229318334714183283292591124797119479179394376119759972315478312",
        "9269611539112923941193374337611812273918782182111711228427912932296164741975399476436521399232611411",
        "9121614993242617961129113713945816376519116179731694591819925123143171631946122131119165191268899289",
        "3742884711891125959671491792344349183328253285436718419711971691631991651911113672513227961721934331",
        "8386429171626218818331257434191312391838221163873213171952144474839144447959323981181924964139114743",
        "8559951249535321919111326533269294228753311471313239139712918148811118291248147293998923231824825953",
        "2789117919873315689147799878123695111353222423721757995381929611588473162137467168231869271324231355",
        "7914627695211918114193931949264919292219928123824441531634314333793231287191917166925593913153482232",
        "1262112726194175111191797116111399224811131184323341138153831263112157229911915168161253225238752494",
        "1131236973684481251933224999151945318398522199345615346816294227718215941244184143871881329318569161",
        "2942187879461418913791381619992748188581394114881829182888612315299844313923299592169441832481233925",
        "8142892413414816219212242925171241983422147743391874415186344512195196641427137425188341657542929433",
        "2521911911316278711912358924176128818171299312296391789431219184854899928916531113271994449221194859",
        "8313348333413351612952934112629191629311963993135815829727231241615838142563754833112555469216647317",
        "9633744821772918214829913112189931943123664949532111193996821251928322492279918113124117186171633313",
        "1959512811325548291131164792383211359134673972998953413685257218126191712261169392922969939811611346",
        "4691635924913113169446735419979373331461969496153811615499113111566233695921111412278312151199265118",
        "1911952979162847617491231718412915381719216493885181961982169437835621919225167181352132466947212251",
        "3993213131949137771191157349287169243158355117936813278131499142244112196294691992881118963142812297",
        "7931579884449265469944911352845942797137928351452778381792832311258391913999145929797919628525791211",
        "4289614841271194227719181197121971214316222958475411329519817163112813519758857175113191951611126896",
        "4235131256268377917746199186571115782411268288989513953132994869696761126534881868419335988994944591",
        "7265449192232826611517628179189169912829574829682498614999931937952613247431884311961721991998141236",
        "1919719613934615393146891967337914891846914138977164184312239229494714912151376189817862779992633893",
        "1218485334111292199531181164646847166447541121113192158529328692291391391789562814919816828911988975",
        "2527298831123449891371213818329367387824244141614273298321915195591237972862121745324935118531973233",
        "1194948997852981914333518118114166124898319959113816255947387387992617611194644711119171466672133748",
        "3217752918581197915172732889491321622883486587239111498982651437898374298614278393773899671793581123",
        "1254211818114228385792226321918423856871251825121397819121927898316155628319321519712525422856961615",
        "2625471627416119641844871538338161612118681914831491211115378228922134943591142869796878464129225593",
        "1821712411947735737699227942163662161571111241811119112377385524586972739197313531581118112936881194",
        "9991757561242423292598362221193967375793829756272522298512418764214212271161145253121199611299621268",
        "9719395999111919621971615756117162111359218381455215863964677995737381239411429213638639832518543717",
        "8198198191714482761927275271131811643184668612186526248299266119391191195344428185161412841758671931",
        "2273723799191412198351188375259187551889839175329371179244181895377958133753211314825974132663991739",
        "6814211984227791229348648141939726582529931916859326942822245897694924148831411911131518235628916922",
        "3417895692282481371971281463362226182417895851264753379951497833542139615565212913777416227691431119",
        "6455174227779716346111961999416845124124237136868223311135337294812339861886117319291911231981548199",
        "4319687952311517111727411419921987289728328129165897199362729193761119614468822641935121541215172316",
        "9551464398816197815267855219973799311391725514624214219835111129211214211891513344793234792423179195",
        "1579289734282814931227314738393182655529249281999363195922116129121618525571992211889793134871992185",
        "1957917583169672131992374177294573739792398249364289413551632251165561142155162389611358942142147239",
        "8115436171215339346819152438599865414292116624438272963988492399783991451437571299165292151891143191",
        "6918135343632841518635115413781881515224447253291523618236138487335782512861737648826317711218117228",
        "1131933281358351575735614123421811519822378955438164329957714143292461113488314274536977399292581712",
        "2152418317916392153511213751949513942548165227848181872275332182942881922617789522172817193129374222",
        "7917937117521911746122328994115229818324751148422914281582129582514727981852322315312219199249784928",
        "4199586496373561382244212119621932812736195174962234296424398681753917513498173991483231496113419143",
        "3223313369368256742177628183985197975464168381627127971911693986177414217145124152992879918823111898",
        "3161791917621473317992611126721158233273596192219315391577844241293411128119923941247927697113311161",
        "1518522144186291199161971141117291897196255188322821721273211448871486653875346117613418698536881461",
        "7312568733228619891623791448221532356992822412679217122466489191389673319217119351887273129141768488",
        "3132954394433419221274357395492965169625645963811284595429172694771119215169577629471419777858371861",
        "4525752448161352959212951272784267232911492669259584781713181277313928856962642975558922213992812812",
        "4411699228919883181412127169459462174861199972126617141785113487249317151828319173681165212611474291",
        "2144673427134379179956991554891313913124532943996874192586178544648139177812779281188873892826833721",
        "1717118979766813975495913912261492363828622974373133982175915929414117781145155122952115711171593289",
        "5741122121316841788399928794147349164363323538131525286519747989212822156211293712184883628444991196",
        "5161889958134429989784251461713348212412718118141289328635173938489951145212916978917351396952846819",
        "6594122165189896111937927127466455424793563291192531366721812671212272531653375734786611498937367199",
        "2968693491684139241588455438122195551132335137397286824749298216112984199467932963832572151212184454",
        "8293921312188179793684426113342688491229989511221293834834719589162439113376959732126851252312681119",
        "8666192162454911622411753271211192673299764921591313923222911967312311621681819532394519598511112443",
        "8779793643282146931734827622826421119219889964192992819693683215911999199511458831337111841421522259",
        "1219792916238199521494126131399921334972715212889281599896952289419115991599537188123224451156993341",
        "2251821669779281284113472362112618192934737721241539171236371399149449618411148821994262236195852832",
        "7196137112977332111799616197356858683419865726696927892783859514913997393244662627188669458295215173",
        "5536212691188118713618211237899242871161411959846811961929152213659974537956717248196859922232395713",
        "9151767195118113957117158217616711219382811391922293293497319315161881942914435343191467557891244614",
        "3414127119951269611479179262125713534288923743824197571822177645933283667267196375142247139192311881",
        "8661423691131343581931189157927412282295722941294737782812151975924896133721986591189175866192522966",
        "9921212994331474189312737154711532431523331911992884598347426989993412195325179145125914538124847368",
        "1639118359917119386811693835392919415594212512243391259321174151872162362886618681799539198929283999",
        "9141799415936859175191224531432634646139921391963628791193992211721141899251663116537191693849311591",
        "1541781881492185614438119529991438696917337513811563861889968529734919588441715376811969163838211332",
        "9198751187133981839218541214295384243427368728593997815182717148692782292139332753818719219719311591",
        "7175318434982471167893512469882752619153593992218118111181721987891856458336461339171533457452925119",
        "1171499957276561389282363655177681538957231864391484531933324731455472731955237312149114923512361481",
        "1628315422465119711892467576216462312891631286421695131549249361116218228318144429461592141122938291",
        "5799815937621339981781318639712538178132485317183495697141324744511716692916739592411127412248231724",
        "3939863191548532933819814354527167962317696991959198148921636211178872127268316413941131369534426337",
        "3259512673234461128517343215132571161869341335221173113793111697368128511972421614423219381725229112",
        "5121313815187862142899924619321981716113831391963261113124626387262589199961973176992513134918344991",
        "1472456295678166514812314139392621148816972222192461121181995397795159411129196691817112178597974321",
        "2696571561334173521699391286118462392235814438517137873361191242371365541856467311315134611459519492",
        "1977317492552933151911919385998935122197818127589192887244617929461626952522289647328292723154114456",
        "3437289259373386811484153512188116411137821113618191319282152172714897687391121149137126248311313135",
        "6794828187612538184422171879226312597948117148714337492123259674949823181138199728757191779616541289",
        "9691389126382153541371119592751814333719912451418598114281927149938692919911948737611235984533791389",
        "7517194327393193831789919536224437162986114218925912116719229214841394595559914781371933911191674216",
        "8676199797277622897519172484951266968413527198436711119433871454129115339532217199911174984188311532",
        "8124243751295749113419291185127217294146194815916155295313333231281622793177415132442917171643496523"
    };

    map2 maze;

    for (int i = 0; i < maze.height / 5; ++i) {
        for (int j = 0; j < maze.width / 5; ++j) {
            maze.grid[i][j] = data[i][j] - '0';
        }
    }

    for (int i = 0; i < 5; ++i) {
        for (int j = 0; j < 5; ++j) {
            if (i == 0 && j == 0) {
                continue;
            }
            for (int k = 0; k < maze.height / 5; ++k) {
                for (int l = 0; l < maze.width / 5; ++l) {
                    maze.grid[(maze.height / 5) * i + k][(maze.width / 5) * j + l] = maze.grid[k][l] + (i + j);
                    switch (maze.grid[(maze.height / 5) * i + k][(maze.width / 5) * j + l]) {
                        case 10:
                            maze.grid[(maze.height / 5) * i + k][(maze.width / 5) * j + l] = 1;
                            break;
                        case 11:
                            maze.grid[(maze.height / 5) * i + k][(maze.width / 5) * j + l] = 2;
                            break;
                        case 12:
                            maze.grid[(maze.height / 5) * i + k][(maze.width / 5) * j + l] = 3;
                            break;
                        case 13:
                            maze.grid[(maze.height / 5) * i + k][(maze.width / 5) * j + l] = 4;
                            break;
                        case 14:
                            maze.grid[(maze.height / 5) * i + k][(maze.width / 5) * j + l] = 5;
                            break;
                        case 15:
                            maze.grid[(maze.height / 5) * i + k][(maze.width / 5) * j + l] = 6;
                            break;
                        case 16:
                            maze.grid[(maze.height / 5) * i + k][(maze.width / 5) * j + l] = 7;
                            break;
                        case 17:
                            maze.grid[(maze.height / 5) * i + k][(maze.width / 5) * j + l] = 8;
                            break;
                        case 18:
                            maze.grid[(maze.height / 5) * i + k][(maze.width / 5) * j + l] = 9;
                            break;
                        case 19:
                            maze.grid[(maze.height / 5) * i + k][(maze.width / 5) * j + l] = 1;
                            break;
                        case 20:
                            maze.grid[(maze.height / 5) * i + k][(maze.width / 5) * j + l] = 2;
                            break;
                    }
                }
            }
        }
    }

    xy start = { 0, 0 };
    xy end = { maze.height - 1, maze.width - 1 };
    std::vector<xy> path;

    gtl::astar<xy, float>::solve(
        start,
        end,
        [&maze](const xy& current) -> std::vector<xy> {
            return maze.get_moves(current);
        },
        [&maze](const xy& current, const xy& target) -> float {
            static_cast<void>(target);
            return static_cast<float>(maze.grid[current.y][current.x]);
        },
        path);

    // maze.print(start, end, path);

    int risk = 0;

    for (std::size_t i = 1; i < path.size(); ++i) {
        risk += maze.grid[path[i].y][path[i].x];
    }

    REQUIRE(risk == 2831);
}
