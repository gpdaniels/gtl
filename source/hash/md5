/*
Copyright (C) 2018-2024 Geoffrey Daniels. https://gpdaniels.com/

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, version 3 of the License only.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

#pragma once
#ifndef GTL_HASH_MD5_HPP
#define GTL_HASH_MD5_HPP

// Summary: An implementation of the md5 hashing function.

#ifndef NDEBUG
#if defined(_MSC_VER)
#define __builtin_trap() __debugbreak()
#endif
/// @brief A simple assert macro to break the program if the md5 is misused.
#define GTL_MD5_ASSERT(ASSERTION, MESSAGE) static_cast<void>((ASSERTION) || (__builtin_trap(), 0))
#else
/// @brief At release time the assert macro is implemented as a nop.
#define GTL_MD5_ASSERT(ASSERTION, MESSAGE) static_cast<void>(0)
#endif

namespace gtl {
    /// @brief  The md5 class computes and MD5 hash of a sequence of data.
    class md5 final {
    public:
        /// @brief  Handy variable for accessing the size in bits.
        constexpr static const unsigned long long int size = 128;

        /// @brief  Size of the hash in bytes.
        constexpr static const unsigned long long int hash_size = md5::size / 8;

        /// @brief  Internal size of each processed block of data in bytes.
        constexpr static const unsigned long long int block_size = 64;

        /// @brief  Number of rounds used to process each block of data.
        constexpr static const unsigned long long int processing_rounds = 64;

    public:
        /// @brief  Simple type to hold the hash data.
        struct hash_type final {
            unsigned char data[md5::hash_size] = {
                0x01,
                0x23,
                0x45,
                0x67,
                0x89,
                0xAB,
                0xCD,
                0xEF,
                0xFE,
                0xDC,
                0xBA,
                0x98,
                0x76,
                0x54,
                0x32,
                0x10
            };
        };

    private:
        /// @brief  Internal type used to construct blocks of data for processing.
        struct block_type final {
            unsigned long long int length_bytes = 0;
            unsigned char data[md5::block_size] = {};
        };

    private:
        /// @brief  The binary integer part of the sines of integers are use as constants.
        /// This can be computed using something like:
        /// for (int i = 0; i < 64; ++i) {
        ///     constants[i] = floor(232 x abs(sin(i + 1)))
        /// }
        constexpr static const unsigned char constants[md5::processing_rounds][4] = {
            { 0x78, 0xA4, 0x6A, 0xD7 },
            { 0x56, 0xB7, 0xC7, 0xE8 },
            { 0xDB, 0x70, 0x20, 0x24 },
            { 0xEE, 0xCE, 0xBD, 0xC1 },
            { 0xAF, 0x0F, 0x7C, 0xF5 },
            { 0x2A, 0xC6, 0x87, 0x47 },
            { 0x13, 0x46, 0x30, 0xA8 },
            { 0x01, 0x95, 0x46, 0xFD },
            { 0xD8, 0x98, 0x80, 0x69 },
            { 0xAF, 0xF7, 0x44, 0x8B },
            { 0xB1, 0x5B, 0xFF, 0xFF },
            { 0xBE, 0xD7, 0x5C, 0x89 },
            { 0x22, 0x11, 0x90, 0x6B },
            { 0x93, 0x71, 0x98, 0xFD },
            { 0x8E, 0x43, 0x79, 0xA6 },
            { 0x21, 0x08, 0xB4, 0x49 },
            { 0x62, 0x25, 0x1E, 0xF6 },
            { 0x40, 0xB3, 0x40, 0xC0 },
            { 0x51, 0x5A, 0x5E, 0x26 },
            { 0xAA, 0xC7, 0xB6, 0xE9 },
            { 0x5D, 0x10, 0x2F, 0xD6 },
            { 0x53, 0x14, 0x44, 0x02 },
            { 0x81, 0xE6, 0xA1, 0xD8 },
            { 0xC8, 0xFB, 0xD3, 0xE7 },
            { 0xE6, 0xCD, 0xE1, 0x21 },
            { 0xD6, 0x07, 0x37, 0xC3 },
            { 0x87, 0x0D, 0xD5, 0xF4 },
            { 0xED, 0x14, 0x5A, 0x45 },
            { 0x05, 0xE9, 0xE3, 0xA9 },
            { 0xF8, 0xA3, 0xEF, 0xFC },
            { 0xD9, 0x02, 0x6F, 0x67 },
            { 0x8A, 0x4C, 0x2A, 0x8D },
            { 0x42, 0x39, 0xFA, 0xFF },
            { 0x81, 0xF6, 0x71, 0x87 },
            { 0x22, 0x61, 0x9D, 0x6D },
            { 0x0C, 0x38, 0xE5, 0xFD },
            { 0x44, 0xEA, 0xBE, 0xA4 },
            { 0xA9, 0xCF, 0xDE, 0x4B },
            { 0x60, 0x4B, 0xBB, 0xF6 },
            { 0x70, 0xBC, 0xBF, 0xBE },
            { 0xC6, 0x7E, 0x9B, 0x28 },
            { 0xFA, 0x27, 0xA1, 0xEA },
            { 0x85, 0x30, 0xEF, 0xD4 },
            { 0x05, 0x1D, 0x88, 0x04 },
            { 0x39, 0xD0, 0xD4, 0xD9 },
            { 0xE5, 0x99, 0xDB, 0xE6 },
            { 0xF8, 0x7C, 0xA2, 0x1F },
            { 0x65, 0x56, 0xAC, 0xC4 },
            { 0x44, 0x22, 0x29, 0xF4 },
            { 0x97, 0xFF, 0x2A, 0x43 },
            { 0xA7, 0x23, 0x94, 0xAB },
            { 0x39, 0xA0, 0x93, 0xFC },
            { 0xC3, 0x59, 0x5B, 0x65 },
            { 0x92, 0xCC, 0x0C, 0x8F },
            { 0x7D, 0xF4, 0xEF, 0xFF },
            { 0xD1, 0x5D, 0x84, 0x85 },
            { 0x4F, 0x7E, 0xA8, 0x6F },
            { 0xE0, 0xE6, 0x2C, 0xFE },
            { 0x14, 0x43, 0x01, 0xA3 },
            { 0xA1, 0x11, 0x08, 0x4E },
            { 0x82, 0x7E, 0x53, 0xF7 },
            { 0x35, 0xF2, 0x3A, 0xBD },
            { 0xBB, 0xD2, 0xD7, 0x2A },
            { 0x91, 0xD3, 0x86, 0xEB }
        };

        /// @brief  The per round shift amounts for the MD5 algorithm.
        constexpr static const unsigned int per_round_shift_amount[md5::processing_rounds / 4] = {
            7,
            12,
            17,
            22,
            5,
            9,
            14,
            20,
            4,
            11,
            16,
            23,
            6,
            10,
            15,
            21
        };

    private:
        /// @brief  The number of bytes of data that have been hashed.
        unsigned long long int hashed_length = 0;

        /// @brief  The current block of data being filled.
        block_type current_block = {};

        /// @brief  The current hash.
        hash_type current_hash = {};

        /// @brief  Flag showing whether the hash has been finalised.
        bool finalised = false;

    private:
        /// @brief  Packs four bytes into an unsigned int.
        /// @param  bytes The bytes to convert.
        /// @return The bytes packed into an unsigned int.
        constexpr static unsigned int pack_little_endian(const unsigned char bytes[4]) {
            return (static_cast<unsigned int>(bytes[0]) << 0) | (static_cast<unsigned int>(bytes[1]) << 8) | (static_cast<unsigned int>(bytes[2]) << 16) | (static_cast<unsigned int>(bytes[3]) << 24);
        }

        /// @brief  Unpacks four bytes from an unsigned int.
        /// @param  value The value to unpack.
        /// @param  bytes The bytes to receive the unpacked data.
        constexpr static void unpack_little_endian(unsigned int value, unsigned char bytes[4]) {
            bytes[0] = static_cast<unsigned char>((value >> 0) & 0xFF);
            bytes[1] = static_cast<unsigned char>((value >> 8) & 0xFF);
            bytes[2] = static_cast<unsigned char>((value >> 16) & 0xFF);
            bytes[3] = static_cast<unsigned char>((value >> 24) & 0xFF);
        }

        /// @brief  Rotate a 32 bit value left by a shift amount.
        /// @param  value The value to rotate.
        /// @param  shift The number of bits to rotate by.
        /// @return The value after it has been rotated left by shift bits.
        constexpr static unsigned int rotate_left(unsigned int value, unsigned int shift) {
            constexpr const unsigned int mask = (8 * sizeof(unsigned int) - 1);
            shift &= mask;
            return (value << shift) | (value >> ((static_cast<unsigned int>(-static_cast<signed int>(shift))) & mask));
        }

    private:
        /// @brief  Perform the hashing algorithm on a current_block of data.
        constexpr void hash_block() {
            unsigned int A = pack_little_endian(&this->current_hash.data[0 * 4]);
            unsigned int B = pack_little_endian(&this->current_hash.data[1 * 4]);
            unsigned int C = pack_little_endian(&this->current_hash.data[2 * 4]);
            unsigned int D = pack_little_endian(&this->current_hash.data[3 * 4]);

            // Do the hash iterations.
            for (unsigned int iteration = 0; iteration < md5::processing_rounds; ++iteration) {
                unsigned int F = 0;
                unsigned int G = 0;

                if (iteration < 16) {
                    F = (B & C) | ((~B) & D);
                    G = iteration;
                }
                else if (iteration < 32) {
                    F = (D & B) | ((~D) & C);
                    G = (5 * iteration + 1) & 0xF;
                }
                else if (iteration < 48) {
                    F = B ^ C ^ D;
                    G = (3 * iteration + 5) & 0xF;
                }
                else {
                    F = C ^ (B | (~D));
                    G = (7 * iteration) & 0xF;
                }

                const unsigned int constant = pack_little_endian(&md5::constants[iteration][0]);
                const unsigned int shift = md5::per_round_shift_amount[((iteration / 16) * 4) + (iteration % 4)];
                const unsigned int block_data = pack_little_endian(&this->current_block.data[G * 4]);

                unsigned int next_A = D;
                D = C;
                C = B;
                B += rotate_left(A + F + constant + block_data, shift);
                A = next_A;
            }

            unpack_little_endian(pack_little_endian(&this->current_hash.data[0 * 4]) + A, &this->current_hash.data[0 * 4]);
            unpack_little_endian(pack_little_endian(&this->current_hash.data[1 * 4]) + B, &this->current_hash.data[1 * 4]);
            unpack_little_endian(pack_little_endian(&this->current_hash.data[2 * 4]) + C, &this->current_hash.data[2 * 4]);
            unpack_little_endian(pack_little_endian(&this->current_hash.data[3 * 4]) + D, &this->current_hash.data[3 * 4]);
        }

    public:
        /// @brief  Reset the internal state of the current_hash.
        constexpr void reset() {
            this->hashed_length = 0;
            this->current_block = {};
            this->current_hash = {};
            this->finalised = false;
        }

        /// @brief  Consume data, constructing blocks and hashing as needed.
        /// @param  data Input data pointer.
        /// @param  length Valid length of the input data pointer.
        constexpr void consume(const char* data, unsigned long long int length) {
            GTL_MD5_ASSERT(this->finalised == false, "Finalise must not be called before consume().");
            GTL_MD5_ASSERT(this->hashed_length <= this->hashed_length + length, "Total hashed data must be less than 2^64 bytes.");

            // Count how much data has been consumed.
            this->hashed_length += length;

            // Block construction and processing.
            while (length--) {
                // Append data to the current block.
                this->current_block.data[this->current_block.length_bytes++] = static_cast<unsigned char>(*data++);

                // If full, hash.
                if (this->current_block.length_bytes == md5::block_size) {
                    this->hash_block();
                    this->current_block = {};
                }
            }
        }

        /// @brief  Finishes processing any remaining buffered data.
        constexpr void finalise() {
            GTL_MD5_ASSERT(this->finalised == false, "Finalise must not be called before finalise().");

            // Pad the data with a single 0x80 on the end.
            this->current_block.data[this->current_block.length_bytes++] = 0x80;

            // Check if there is enough space in the final chunk for the data length.
            if (this->current_block.length_bytes > (md5::block_size - sizeof(unsigned long long int))) {
                this->hash_block();
                this->current_block = {};
            }

            // Add the data length to the chunk (Must be little endian).
            const unsigned long long int hashed_length_bits = this->hashed_length * 8;
            unpack_little_endian((hashed_length_bits >> 0) & 0xFFFFFFFF, &this->current_block.data[md5::block_size - 8]);
            unpack_little_endian((hashed_length_bits >> 32) & 0xFFFFFFFF, &this->current_block.data[md5::block_size - 4]);

            // Hash the block.
            this->hash_block();

            // Done.
            this->finalised = true;
        }

        /// @brief  Calculate the final current_hash from the state and return it.
        /// @return The resultant current_hash.
        constexpr const hash_type& get_hash() const {
            GTL_MD5_ASSERT(this->finalised == true, "Finalise must be called before get_hash().");
            return this->current_hash;
        }

    public:
        /// @brief  Simple type to hold the string representation of the hash.
        struct hash_string_type final {
            char hash[(md5::hash_size * 2) + 1] = {};
        };

        /// @brief  Convert a hash into its string representation.
        /// @param  hash The hash to convert.
        /// @return The string representation of the hash, with null termination.
        constexpr static hash_string_type hash_to_string(const hash_type& hash) {
            hash_string_type output;
            constexpr const char* hex_characters = "0123456789ABCDEF";
            for (unsigned int index = 0; index < (md5::hash_size * 2); ++index) {
                output.hash[index] = hex_characters[(hash.data[index / 2] >> ((1 - (index % 2)) * 4)) & 0xF];
            }
            output.hash[md5::hash_size * 2] = 0;
            return output;
        }

    public:
        /// @brief  Hash a buffer of data.
        /// @param  data Input data pointer.
        /// @param  length Valid length of the input data pointer.
        static hash_type hash(const char* data, const unsigned long long int length) {
            md5 hash_function;
            hash_function.reset();
            hash_function.consume(data, length);
            hash_function.finalise();
            return hash_function.get_hash();
        }
    };
}

#undef GTL_MD5_ASSERT

#endif // GTL_HASH_MD5_HPP
