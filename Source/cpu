/*
The MIT License
Copyright (c) 2018 Geoffrey Daniels. http://gpdaniels.com/
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE
*/

#ifndef GTL_CPU_HPP
#define GTL_CPU_HPP

#if defined _MSC_VER
#   include <intrin.h>
#else
#   include <cpuid.h>
#endif

#if defined(_MSC_VER)
#   pragma warning(push, 0)
#endif

#include <array>
#include <cstdint>
#include <string>
#include <vector>

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

namespace gtl {
    /// @brief  The cpu class extracts information about the current cpu.
    class cpu {
    public:
        constexpr static const std::uint32_t leaf_vendor_id                 = 0x00000000u;
        constexpr static const std::uint32_t leaf_feature_bits              = 0x00000001u;
        constexpr static const std::uint32_t leaf_cache_and_tlb             = 0x00000002u;
        constexpr static const std::uint32_t leaf_serial_number             = 0x00000003u;
        constexpr static const std::uint32_t leaf_thread_core_and_cache     = 0x00000004u;
        constexpr static const std::uint32_t leaf_extended_feature_bits     = 0x00000007u;

        constexpr static const std::uint32_t extended_leaf_highest_function = 0x80000000u;
        constexpr static const std::uint32_t extended_leaf_feature_bits     = 0x80000001u;
        constexpr static const std::uint32_t extended_leaf_brand_string_0   = 0x80000002u;
        constexpr static const std::uint32_t extended_leaf_brand_string_1   = 0x80000003u;
        constexpr static const std::uint32_t extended_leaf_brand_string_2   = 0x80000004u;
        constexpr static const std::uint32_t extended_leaf_l1_cache_and_tlb = 0x80000005u;
        constexpr static const std::uint32_t extended_leaf_l2_cache         = 0x80000005u;
        constexpr static const std::uint32_t extended_leaf_power_management = 0x80000007u;
        constexpr static const std::uint32_t extended_leaf_raw_size         = 0x80000008u;

        constexpr static const std::uint32_t register_eax_index = 0;
        constexpr static const std::uint32_t register_ebx_index = 1;
        constexpr static const std::uint32_t register_ecx_index = 2;
        constexpr static const std::uint32_t register_edx_index = 3;

    private:
        /// @brief  This array of arrays stores all the extractable cpu information.
        std::vector<std::array<std::uint32_t, 4u> > cpu_data;

        /// @brief  This array of arrays stores all the extractable extended cpu information.
        std::vector<std::array<std::uint32_t, 4u> > cpu_extended_data;

    private:
        /// @brief  Helper function for getting values from the cpuid instruction.
        /// @param  leaf_id The leaf number to read.
        /// @return An array of four 32 bit values that hold the values of the registers eax, ebx, ecx, and edx;
        std::array<std::uint32_t, 4> query_cpuid(std::uint32_t leaf_id) {
            std::array<std::uint32_t, 4> leaf_data;
            #if defined(_MSC_VER)
                __cpuidex(reinterpret_cast<int*>(leaf_data.data()), leaf_id, 0u);
            #elif defined(__GNUC__)
                __cpuid_count(leaf_id, 0u, leaf_data[cpu::register_eax_index], leaf_data[cpu::register_ebx_index], leaf_data[cpu::register_ecx_index], leaf_data[cpu::register_edx_index]);
            #else
                leaf_data = {};
            #endif
            return leaf_data;
        }

    public:
        /// @brief  The constructor extracts all available cpu information and stores it in an array.
        cpu() {
            // First get the maximum supported cpuid leaf and the manufacturer id by calling with a cpuid leaf of 0x00000000.
            this->cpu_data.emplace_back(this->query_cpuid(cpu::leaf_vendor_id));

            // Reserve memory for cpu_data to fit remaining queries.
            this->cpu_data.reserve(this->get_max_leaf_id());

            // Extract every leaf.
            for (std::uint32_t leaf_id = 1u; leaf_id < this->get_max_leaf_id(); ++leaf_id) {
                this->cpu_data.emplace_back(this->query_cpuid(leaf_id));
            }

            // Get the maximum supported cpuid extended leaf by calling with a cpuid leaf of 0x80000000.
            this->cpu_extended_data.emplace_back(this->query_cpuid(cpu::extended_leaf_highest_function));

            // Reserve memory for cpu_extended_data to fit remaining queries.
            this->cpu_extended_data.reserve(this->get_max_extended_leaf_id());

            // Extract every extended leaf.
            for (std::uint32_t leaf_id = 1u; leaf_id < this->get_max_extended_leaf_id(); ++leaf_id) {
                this->cpu_extended_data.emplace_back(this->query_cpuid(leaf_id | 0x80000000u));
            }
        }

    public:
        /// @brief  Check the build is compatible with the cpu.
        /// @return true if the build flags are a subset of the available cpu instructions, false otherwise.
        bool is_build_compatible() {
            #if defined(__MMX__)
                if (!this->has_mmx()) return false;
            #endif

            #if defined(__SSE__)
                if (!this->has_sse()) return false;
            #endif
            #if defined(__SSE2__)
                if (!this->has_sse2()) return false;
            #endif
            #if defined(__SSE3__)
                if (!this->has_sse3()) return false;
            #endif
            #if defined(__SSSE3__)
                if (!this->has_ssse3()) return false;
            #endif
            #if defined(__SSE4_1__)
                if (!this->has_sse4_1()) return false;
            #endif
            #if defined(__SSE4_2__)
                if (!this->has_sse4_2()) return false;
            #endif

            #if defined(__POPCNT__)
                if (!this->has_popcnt()) return false;
            #endif

            #if defined(__AVX__)
                if (!this->has_avx()) return false;
            #endif
            #if defined(__AVX2__)
                if (!this->has_avx2()) return false;
            #endif

            #if defined(__AVX512F__)
                if (!this->has_avx512_foundation()) return false;
            #endif

            #if defined(__BMI__)
                if (!this->has_bmi()) return false;
            #endif

            #if defined(__BMI2__)
                if (!this->has_bmi2()) return false;
            #endif

            return true;
        }

    public:
        /// @brief  Get the value of a single bit in one of the extracted leafs registers.
        /// @param  leaf_id The id number of the leaf to read.
        /// @param  register_id The register number within a leaf.
        /// @param  bit_id The individual bit number within a register.
        /// @return true if the specified bit is 1 in the specified leaf register, false otherwise.
        bool get_leaf_register_bit(std::uint32_t leaf_id, std::uint32_t register_id, std::uint32_t bit_id) const {
            // Check the requested leaf_id is within those available.
            if (this->get_max_leaf_id() < leaf_id) {
                return false;
            }

            // Double check the requested leaf_id is within those available.
            if (this->cpu_data.size() <= leaf_id) {
                return false;
            }

            // Check the register_id is one of the four available.
            if (register_id > 3u) {
                return false;
            }

            // Check the bit_id is within the size of a register.
            if (bit_id > 31u) {
                return false;
            }

            // Return the extracted value of the bit.
            return this->cpu_data[leaf_id][register_id] & (1u << bit_id);
        }

        /// @brief  Get the value of a single bit in one of the extracted extended leafs registers.
        /// @param  extended_leaf_id The id number of the leaf to read.
        /// @param  register_id The register number within a leaf.
        /// @param  bit_id The individual bit number within a register.
        /// @return true if the specified bit is 1 in the specified leaf register, false otherwise.
        bool get_extended_leaf_register_bit(std::uint32_t extended_leaf_id, std::uint32_t register_id, std::uint32_t bit_id) const {
            // First remove the top bit.
            extended_leaf_id = extended_leaf_id & 0x7FFFFFFFu;

            // Check the requested leaf_id is within those available.
            if (this->get_max_extended_leaf_id() < extended_leaf_id) {
                return false;
            }

            // Double check the requested leaf_id is within those available.
            if (this->cpu_extended_data.size() <= extended_leaf_id) {
                return false;
            }

            // Check the register_id is one of the four available.
            if (register_id > 3u) {
                return false;
            }

            // Check the bit_id is within the size of a register.
            if (bit_id > 31u) {
                return false;
            }

            // Return the extracted value of the bit.
            return this->cpu_extended_data[extended_leaf_id][register_id] & (1u << bit_id);
        }

    public:
        /// @brief  Get the maximum valid leaf number for this processor.
        /// @return The maximum valid leaf number for this processor.
        std::uint32_t get_max_leaf_id() const {
            return this->cpu_data[cpu::leaf_vendor_id][cpu::register_eax_index];
        }

        /// @brief  Get the name of the processors manufacturer.
        /// @return The name of the manufacturer of this processor as a string.
        std::string get_manufacturer_id() const {
            std::string manufacturer_id;
            manufacturer_id.reserve(13u);
            manufacturer_id.append(reinterpret_cast<const char*>(&this->cpu_data[cpu::leaf_vendor_id][cpu::register_ebx_index]), 4u);
            manufacturer_id.append(reinterpret_cast<const char*>(&this->cpu_data[cpu::leaf_vendor_id][cpu::register_edx_index]), 4u);
            manufacturer_id.append(reinterpret_cast<const char*>(&this->cpu_data[cpu::leaf_vendor_id][cpu::register_ecx_index]), 4u);
            return manufacturer_id;
        }

    public:
        /// @brief  Check if mmx instructions are supported.
        /// @return true if the instruction is supported, false otherwise.
        bool has_mmx() const {
            return this->get_leaf_register_bit(cpu::leaf_feature_bits, cpu::register_edx_index, 23);
        }

        /// @brief  Check if fma instructions are supported.
        /// @return true if the instruction is supported, false otherwise.
        bool has_fma() const {
            return this->get_leaf_register_bit(cpu::leaf_feature_bits, cpu::register_ecx_index, 12);
        }

        /// @brief  Check if sse instructions are supported.
        /// @return true if the instruction is supported, false otherwise.
        bool has_sse() const {
            return this->get_leaf_register_bit(cpu::leaf_feature_bits, cpu::register_edx_index, 25);
        }

        /// @brief  Check if sse2 instructions are supported.
        /// @return true if the instruction is supported, false otherwise.
        bool has_sse2() const {
            return this->get_leaf_register_bit(cpu::leaf_feature_bits, cpu::register_edx_index, 26);
        }

        /// @brief  Check if sse3 instructions are supported.
        /// @return true if the instruction is supported, false otherwise.
        bool has_sse3() const {
            return this->get_leaf_register_bit(cpu::leaf_feature_bits, cpu::register_ecx_index, 0);
        }

        /// @brief  Check if ssse3 instructions are supported.
        /// @return true if the instruction is supported, false otherwise.
        bool has_ssse3() const {
            return this->get_leaf_register_bit(cpu::leaf_feature_bits, cpu::register_ecx_index, 9);
        }

        /// @brief  Check if sse4.1 instructions are supported.
        /// @return true if the instruction is supported, false otherwise.
        bool has_sse4_1() const {
            return this->get_leaf_register_bit(cpu::leaf_feature_bits, cpu::register_ecx_index, 19);
        }

        /// @brief  Check if sse4.2 instructions are supported.
        /// @return true if the instruction is supported, false otherwise.
        bool has_sse4_2() const {
            return this->get_leaf_register_bit(cpu::leaf_feature_bits, cpu::register_ecx_index, 20);
        }

        /// @brief  Check if popcnt instructions are supported.
        /// @return true if the instruction is supported, false otherwise.
        bool has_popcnt() const {
            return this->get_leaf_register_bit(cpu::leaf_feature_bits, cpu::register_ecx_index, 23);
        }

        /// @brief  Check if avx instructions are supported.
        /// @return true if the instruction is supported, false otherwise.
        bool has_avx() const {
            return this->get_leaf_register_bit(cpu::leaf_feature_bits, cpu::register_ecx_index, 28);
        }

        /// @brief  Check if avx2 instructions are supported.
        /// @return true if the instruction is supported, false otherwise.
        bool has_avx2() const {
            return this->get_leaf_register_bit(cpu::leaf_extended_feature_bits, cpu::register_ebx_index, 5);
        }

        /// @brief  Check if avx512 foundation instructions are supported.
        /// @return true if the instruction is supported, false otherwise.
        bool has_avx512_foundation() const {
            return this->get_extended_leaf_register_bit(cpu::leaf_extended_feature_bits, cpu::register_ebx_index, 16);
        }

        /// @brief  Check if bmi instructions are supported.
        /// @return true if the instruction is supported, false otherwise.
        bool has_bmi() const {
            return this->get_leaf_register_bit(cpu::leaf_extended_feature_bits, cpu::register_ebx_index, 3);
        }

        /// @brief  Check if bmi2 instructions are supported.
        /// @return true if the instruction is supported, false otherwise.
        bool has_bmi2() const {
            return this->get_leaf_register_bit(cpu::leaf_extended_feature_bits, cpu::register_ebx_index, 8);
        }

    public:
        /// @brief  Get the maximum valid extended leaf number for this processor.
        /// @return The maximum valid extended leaf number for this processor.
        std::uint32_t get_max_extended_leaf_id() const {
            return this->cpu_extended_data[cpu::extended_leaf_highest_function & 0x7FFFFFFFu][cpu::register_eax_index] & 0x7FFFFFFFu;
        }

        /// @brief  Get the brand string of the processors manufacturer.
        /// @return The brand string of the manufacturer of this processor as a string.
        std::string get_brand_string() const {
            std::string brand_string;
            brand_string.reserve(49u);
            brand_string.append(reinterpret_cast<const char*>(&this->cpu_extended_data[cpu::extended_leaf_brand_string_0 & 0x7FFFFFFFu][cpu::register_eax_index]), 4u);
            brand_string.append(reinterpret_cast<const char*>(&this->cpu_extended_data[cpu::extended_leaf_brand_string_0 & 0x7FFFFFFFu][cpu::register_ebx_index]), 4u);
            brand_string.append(reinterpret_cast<const char*>(&this->cpu_extended_data[cpu::extended_leaf_brand_string_0 & 0x7FFFFFFFu][cpu::register_ecx_index]), 4u);
            brand_string.append(reinterpret_cast<const char*>(&this->cpu_extended_data[cpu::extended_leaf_brand_string_0 & 0x7FFFFFFFu][cpu::register_edx_index]), 4u);

            brand_string.append(reinterpret_cast<const char*>(&this->cpu_extended_data[cpu::extended_leaf_brand_string_1 & 0x7FFFFFFFu][cpu::register_eax_index]), 4u);
            brand_string.append(reinterpret_cast<const char*>(&this->cpu_extended_data[cpu::extended_leaf_brand_string_1 & 0x7FFFFFFFu][cpu::register_ebx_index]), 4u);
            brand_string.append(reinterpret_cast<const char*>(&this->cpu_extended_data[cpu::extended_leaf_brand_string_1 & 0x7FFFFFFFu][cpu::register_ecx_index]), 4u);
            brand_string.append(reinterpret_cast<const char*>(&this->cpu_extended_data[cpu::extended_leaf_brand_string_1 & 0x7FFFFFFFu][cpu::register_edx_index]), 4u);

            brand_string.append(reinterpret_cast<const char*>(&this->cpu_extended_data[cpu::extended_leaf_brand_string_2 & 0x7FFFFFFFu][cpu::register_eax_index]), 4u);
            brand_string.append(reinterpret_cast<const char*>(&this->cpu_extended_data[cpu::extended_leaf_brand_string_2 & 0x7FFFFFFFu][cpu::register_ebx_index]), 4u);
            brand_string.append(reinterpret_cast<const char*>(&this->cpu_extended_data[cpu::extended_leaf_brand_string_2 & 0x7FFFFFFFu][cpu::register_ecx_index]), 4u);
            brand_string.append(reinterpret_cast<const char*>(&this->cpu_extended_data[cpu::extended_leaf_brand_string_2 & 0x7FFFFFFFu][cpu::register_edx_index]), 4u);

            // Trim the null chars off the end.
            std::size_t brand_string_size = brand_string.find_last_not_of('\0');
            if (brand_string_size != std::string::npos) {
                brand_string.resize(brand_string_size + 1);
            }
            return brand_string;
        }
    };
}

#endif // GTL_CPU_HPP
