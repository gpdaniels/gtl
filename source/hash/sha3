/*
Copyright (C) 2018-2024 Geoffrey Daniels. https://gpdaniels.com/

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, version 3 of the License only.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

#pragma once
#ifndef GTL_HASH_SHA3_HPP
#define GTL_HASH_SHA3_HPP

// Summary: An implementation of the sha3 hashing function for 224, 256, 384, and 512 bits.

#ifndef NDEBUG
#if defined(_MSC_VER)
#define __builtin_trap() __debugbreak()
#endif
/// @brief A simple assert macro to break the program if the sha3 is misused.
#define GTL_SHA3_ASSERT(ASSERTION, MESSAGE) static_cast<void>((ASSERTION) || (__builtin_trap(), 0))
#else
/// @brief At release time the assert macro is implemented as a nop.
#define GTL_SHA3_ASSERT(ASSERTION, MESSAGE) static_cast<void>(0)
#endif

namespace gtl {
    /// @brief  The sha3 class computes a SHA3 hash of a sequence of data.
    /// @tparam sha3_size The size parameter allows for the selection of different hash lengths.
    template <unsigned long long int sha3_size>
    class sha3 final {
    private:
        static_assert(sha3_size % 8 == 0, "Size of sha3 hash must be a multiple of eight.");
        static_assert(sha3_size == 224 || sha3_size == 256 || sha3_size == 384 || sha3_size == 512, "Currently only sizes 224, 256, 384, and 512 bits are supported.");

    public:
        /// @brief  Handy variable for accessing the size in bits.
        constexpr static const unsigned long long int size = sha3_size;

        /// @brief  Size of the hash in bytes.
        constexpr static const unsigned long long int hash_size = sha3::size / 8;

        /// @brief  Size of the sponge state used for processing blocks.
        constexpr static const unsigned int state_size = (5 * 5 * 64) / 8;

        /// @brief  Size of each processed block of data in bytes.
        constexpr static const unsigned long long int block_size = sha3::state_size - (2 * sha3::hash_size);

        /// @brief  Number of rounds used to process each block of data.
        constexpr static const unsigned long long int processing_rounds = 24;

    public:
        struct hash_type final {
            unsigned char data[sha3::hash_size] = {};
        };

    private:
        /// @brief  Internal type used to construct blocks of data for processing.
        struct block_type final {
            unsigned long long int length_bytes = 0;
            unsigned char data[sha3::block_size] = {};
        };

        struct state_type final {
            unsigned char data[sha3::state_size] = {};
        };

    private:
        constexpr static const unsigned char round_constants[sha3::processing_rounds][8] = {
            { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
            { 0x82, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
            { 0x8a, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80 },
            { 0x00, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80 },
            { 0x8b, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
            { 0x01, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00 },
            { 0x81, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80 },
            { 0x09, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80 },
            { 0x8a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
            { 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
            { 0x09, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00 },
            { 0x0a, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00 },
            { 0x8b, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00 },
            { 0x8b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80 },
            { 0x89, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80 },
            { 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80 },
            { 0x02, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80 },
            { 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80 },
            { 0x0a, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
            { 0x0a, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80 },
            { 0x81, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80 },
            { 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80 },
            { 0x01, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00 },
            { 0x08, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80 }
        };

    private:
        /// @brief  The current block of data being filled.
        block_type current_block = {};

        /// @brief  The current state.
        state_type current_state = {};

        /// @brief  The current hash.
        hash_type current_hash = {};

        /// @brief  Flag showing whether the hash has been finalised.
        bool finalised = false;

    private:
        /// @brief  Rotate a 64-bit lane (8 bytes) left by a shift amount.
        /// @param  bytes The 8-byte array to rotate.
        /// @param  shift The number of bits to rotate by.
        constexpr static void rotate_left(unsigned char bytes[8], unsigned long long int shift) {
            shift %= 64;
            if (shift == 0) {
                return;
            }

            // Create a temporary copy.
            unsigned char temp[8] = {};
            for (unsigned int i = 0; i < 8; ++i) {
                temp[i] = bytes[i];
            }

            // Perform bit rotation across bytes.
            const unsigned long long int byte_shift = shift / 8;
            const unsigned long long int bit_shift = shift % 8;

            for (unsigned int i = 0; i < 8; ++i) {
                if (bit_shift == 0) {
                    bytes[i] = temp[(i - byte_shift + 8) % 8];
                }
                else {
                    const unsigned char low_bits = temp[(i - byte_shift + 8) % 8] << bit_shift;
                    const unsigned char high_bits = temp[(i - byte_shift - 1 + 8) % 8] >> (8 - bit_shift);
                    bytes[i] = low_bits | high_bits;
                }
            }
        }

        /// @brief  Perform the hashing algorithm on a block of data.
        constexpr void hash_block() {
            // Mix input data into the state.
            for (unsigned int i = 0; i < sha3::block_size; ++i) {
                this->current_state.data[i] ^= this->current_block.data[i];
            }

            // Re-compute state.
            for (unsigned int round = 0; round < sha3::processing_rounds; ++round) {
                // Theta (Compute and apply parity).
                unsigned char coefficients[5][8] = {};

                // Compute parity columns.
                for (unsigned int x = 0; x < 5; ++x) {
                    for (unsigned int i = 0; i < 8; ++i) {
                        coefficients[x][i] = 0;
                    }
                    for (unsigned int y = 0; y < 5; ++y) {
                        const unsigned int offset = (x + 5 * y) * 8;
                        for (unsigned int i = 0; i < 8; ++i) {
                            coefficients[x][i] ^= this->current_state.data[offset + i];
                        }
                    }
                }

                // Apply theta transformation.
                for (unsigned int x = 0; x < 5; ++x) {
                    unsigned char parity[8] = {};
                    unsigned char rotated[8] = {};

                    // Copy coefficients[(x + 1) % 5] and rotate.
                    for (unsigned int i = 0; i < 8; ++i) {
                        rotated[i] = coefficients[(x + 1) % 5][i];
                    }
                    rotate_left(rotated, 1);

                    // XOR with coefficients[(x + 4) % 5] to get parity.
                    for (unsigned int i = 0; i < 8; ++i) {
                        parity[i] = coefficients[(x + 4) % 5][i] ^ rotated[i];
                    }

                    // Apply parity to all lanes in this column.
                    for (unsigned int y = 0; y < 5; ++y) {
                        const unsigned int offset = (x + 5 * y) * 8;
                        for (unsigned int i = 0; i < 8; ++i) {
                            this->current_state.data[offset + i] ^= parity[i];
                        }
                    }
                }

                // Rho (Bitwise rotation).
                unsigned int index_2d[2] = { 0, 1 };
                for (unsigned int i = 0; i < 24; ++i) {
                    // Calculate triangular number to rotate by.
                    const unsigned long long int triangular_number = (((i + 1) * (i + 2)) / 2) % 64;

                    // Calculate offset of data to rotate.
                    const unsigned int offset = (index_2d[1] + 5 * index_2d[0]) * 8;

                    // Rotate the lane in place.
                    rotate_left(&this->current_state.data[offset], triangular_number);

                    // Update index.
                    unsigned int index_temp = 3 * index_2d[0] + 2 * index_2d[1];
                    index_2d[1] = index_2d[0] % 5;
                    index_2d[0] = index_temp % 5;
                }

                // Pi (Permute).
                index_2d[0] = 0;
                index_2d[1] = 1;
                unsigned int offset = (index_2d[1] + 5 * index_2d[0]) * 8;
                unsigned char stored_data[8] = {};
                for (unsigned int i = 0; i < 8; ++i) {
                    stored_data[i] = this->current_state.data[offset + i];
                }

                for (unsigned int i = 0; i < 24; ++i) {
                    // Update index.
                    unsigned int index_temp = 3 * index_2d[0] + 2 * index_2d[1];
                    index_2d[1] = index_2d[0] % 5;
                    index_2d[0] = index_temp % 5;

                    // Calculate offset of data to replace.
                    offset = (index_2d[1] + 5 * index_2d[0]) * 8;

                    // Store current data temporarily.
                    unsigned char temp[8] = {};
                    for (unsigned int j = 0; j < 8; ++j) {
                        temp[j] = this->current_state.data[offset + j];
                    }

                    // Replace data with stored data from last iteration.
                    for (unsigned int j = 0; j < 8; ++j) {
                        this->current_state.data[offset + j] = stored_data[j];
                    }

                    // Store current data outside of loop for next iteration.
                    for (unsigned int j = 0; j < 8; ++j) {
                        stored_data[j] = temp[j];
                    }
                }

                // Chi (Bitwise combine).
                for (unsigned int y = 0; y < 5; ++y) {
                    unsigned char coefficients[5][8] = {};

                    // Read all lanes in this row.
                    for (unsigned int x = 0; x < 5; ++x) {
                        const unsigned int offset = (x + 5 * y) * 8;
                        for (unsigned int i = 0; i < 8; ++i) {
                            coefficients[x][i] = this->current_state.data[offset + i];
                        }
                    }

                    // Apply chi transformation: result = a ^ ((~b) & c)
                    for (unsigned int x = 0; x < 5; ++x) {
                        const unsigned int offset = (x + 5 * y) * 8;
                        for (unsigned int i = 0; i < 8; ++i) {
                            this->current_state.data[offset + i] = coefficients[x][i] ^ ((~coefficients[(x + 1) % 5][i]) & coefficients[(x + 2) % 5][i]);
                        }
                    }
                }

                // Iota (Xor with round constant).
                for (unsigned int i = 0; i < 8; ++i) {
                    this->current_state.data[i] ^= sha3::round_constants[round][i];
                }
            }
        }

    public:
        /// @brief  Reset the internal state of the hash.
        constexpr void reset() {
            this->current_block = {};
            this->current_state = {};
            this->current_hash = {};
            this->finalised = false;
        }

        /// @brief  Consume data, constructing blocks and hashing as needed.
        /// @param  data Input data pointer.
        /// @param  length Valid length of the input data pointer.
        constexpr void consume(const char* data, unsigned long long int length) {
            GTL_SHA3_ASSERT(this->finalised == false, "Finalise must not be called before consume().");

            // Block construction and processing.
            while (length--) {
                // Append data to the current block.
                this->current_block.data[this->current_block.length_bytes++] |= static_cast<unsigned char>(*data++);

                // If full, hash.
                if (this->current_block.length_bytes == sha3::block_size) {
                    this->hash_block();
                    this->current_block = {};
                }
            }
        }

        /// @brief  Finishes processing any remaining buffered data.
        constexpr void finalise() {
            GTL_SHA3_ASSERT(this->finalised == false, "Finalise must not be called before finalise().");

            // Pad as is required by the sha3 specification.
            this->current_block.data[this->current_block.length_bytes++] = static_cast<unsigned char>(0x02 | (1 << 2));

            // Pad the data with another single bit at the end.
            this->current_block.data[sha3::block_size - 1] |= 0x80;

            // Hash the block.
            this->hash_block();

            // Consume state into hash.
            for (unsigned int i = 0; i < sha3::hash_size; ++i) {
                this->current_hash.data[i] = this->current_state.data[i];
            }

            this->finalised = true;
        }

        /// @brief  Calculate the final hash from the state and return it.
        /// @return The resultant hash.
        constexpr const hash_type& get_hash() const {
            GTL_SHA3_ASSERT(this->finalised == true, "Finalise must be called before get_hash().");
            return this->current_hash;
        }

    public:
        /// @brief  Simple type to hold the string representation of the hash.
        struct hash_string_type final {
            char hash[(sha3::hash_size * 2) + 1] = {};
        };

        /// @brief  Convert a hash into its string representation.
        /// @param  hash The hash to convert.
        /// @return The string representation of the hash, with null termination.
        constexpr static hash_string_type hash_to_string(const hash_type& hash) {
            hash_string_type output;
            constexpr const char* hex_characters = "0123456789ABCDEF";
            for (unsigned int index = 0u; index < (sha3::hash_size * 2); ++index) {
                output.hash[index] = hex_characters[(hash.data[index / 2] >> ((1 - (index % 2)) * 4)) & 0xF];
            }
            output.hash[sha3::hash_size * 2] = 0;
            return output;
        }

    public:
        /// @brief  Hash a buffer of data.
        /// @param  data Input data pointer.
        /// @param  length Valid length of the input data pointer.
        static hash_type hash(const char* data, const unsigned long long int length) {
            sha3 hash_function;
            hash_function.reset();
            hash_function.consume(data, length);
            hash_function.finalise();
            return hash_function.get_hash();
        }
    };

    using sha3_224 = sha3<224>;
    using sha3_256 = sha3<256>;
    using sha3_384 = sha3<384>;
    using sha3_512 = sha3<512>;
}

#undef GTL_SHA3_ASSERT

#endif // GTL_HASH_SHA3_HPP
